<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DDD领域驱动设计</title>
      <link href="/2023/07/14/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/07/14/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="DDD领域驱动设计"><a href="#DDD领域驱动设计" class="headerlink" title="DDD领域驱动设计"></a>DDD领域驱动设计</h1><h2 id="什么是领域驱动设计"><a href="#什么是领域驱动设计" class="headerlink" title="什么是领域驱动设计"></a>什么是领域驱动设计</h2><p>又被称作基于领域的工程设计。</p><p><strong>那么什么是领域？</strong></p><p>我们暂且可以将其理解为<strong>业务问题的范畴</strong>。比如说打扮自己这项业务就可以分为购买衣服、化妆和健身三个领域，而购买衣服这一领域就包括了挑衣服，试衣服和付款。</p><p>总的来说领域驱动设计其实就是将业务上要做的一件<strong>大事</strong>,通过推演和抽象<strong>拆分成多个内聚的领域。</strong></p><h2 id="DDD名词概念"><a href="#DDD名词概念" class="headerlink" title="DDD名词概念"></a>DDD名词概念</h2><h3 id="什么是DP"><a href="#什么是DP" class="headerlink" title="什么是DP"></a>什么是DP</h3><p>Domain Primitive，在DDD中DP可以说是一切模型、方法、架构的基础，他是在特定领域、拥有精确定义、可以自我验证、拥有行为的对象，可以认为是领域的最小组成部分。</p><p>DP的三条原则：</p><ul><li>让隐性的概念显性化：比如手机号码是具有区号的，如果用String来记录手机号码的话就记录不了区号，如果自行创建一个DP对象，里面包括了手机号码和区号等属性，就能做到将隐性概念显性化的。</li><li>让隐性的上下文显性化：隐性的概念都显性化之后，隐性的上下文自然也显性化了。</li><li>封装多对象行为：一个DP可以封装多个DP。</li></ul><h3 id="什么是Entity"><a href="#什么是Entity" class="headerlink" title="什么是Entity"></a>什么是Entity</h3><p>和DP相比，他俩都是<strong>充血</strong>的，但是Entity是有状态的，DP是组成实体的基础类型，Entity则是有状态的领域实体。</p><p>举个例子： 买门票，如果门票有指定位置，那么这个位置就是有状态的Entity，程序需要通过他的唯一id追踪他的状态，预定状态和行列数等等，如果没有指定位置，进到里面随便坐，那么就是无状态的DP，程序只需要知道座位的总数。</p><h3 id="什么是ACL防腐层"><a href="#什么是ACL防腐层" class="headerlink" title="什么是ACL防腐层"></a>什么是ACL防腐层</h3><p>将两个不同的领域界定开，使得两者结构不受对方的影响，可以通过接口的形式，对外提供<br>访问接口，这样即使业务逻辑产生变化，也不会影响别的系统，如果要进行转义，也可以在防腐层内完成。</p><h3 id="有的没的都概览"><a href="#有的没的都概览" class="headerlink" title="有的没的都概览"></a>有的没的都概览</h3><ul><li>DP: 抽象并封装自检和一些隐性属性的计算逻辑，且这些属性是无状态的。</li><li>Entity: 抽象并封装单对象有状态的逻辑。</li><li>Domain Service: 抽象并封装<strong>多对象</strong>的有状态逻辑。</li><li>Repository: 抽象并封装外部数据访问逻辑。</li></ul><h2 id="DDD思想下的编码过程"><a href="#DDD思想下的编码过程" class="headerlink" title="DDD思想下的编码过程"></a>DDD思想下的编码过程</h2><ol><li>首先对需要处理的业务问题进行总览。</li><li>然后领域对象(Entity) 进行划分，明确每个领域对象的包含的信息和职责边界并进行跨对象，多对象的逻辑组织 (Domain Service)。</li><li>接着在上层应用中根据业务描述去编排Entity和Domain Service。</li><li>最后再做一些下水道（脏，耦合高）工作，去对下层的数据访问，RPC调用去做一些具体实现。</li></ol><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>聚合是对存在引用关系的一组对象的封装，他的目的就是屏蔽掉内部对象之间复杂的关联关系只对外暴露统一接口。<br>例子：在写论文时的各种步骤聚合在一起就是一个与写论文相关的聚合。</p><img src="/2023/07/14/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/1.png" class="" title="聚合概念"><h3 id="聚合根"><a href="#聚合根" class="headerlink" title="聚合根"></a>聚合根</h3><p>聚合根是整个聚合当中唯一能够被外部引用的对象，也就是说聚合所暴露的接口只允许操作根对象。</p><h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><p>判断哪些对象可以被划入聚合的条件</p><h3 id="注销微信账号的例子："><a href="#注销微信账号的例子：" class="headerlink" title="注销微信账号的例子："></a>注销微信账号的例子：</h3><p>注销的时候需要检查钱包里的余额，同时还要检查绑定的银行卡，但是聊天消息微信没有保存，所以就不用管了</p><img src="/2023/07/14/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/3.png" class="" title="注销微信账号的例子"><img src="/2023/07/14/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/2.png" class="" title="聚合接口写法"><p>这里手机号就是微信账号的聚合根</p>]]></content>
      
      
      
        <tags>
            
            <tag> DDD </tag>
            
            <tag> 领域驱动设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习笔记</title>
      <link href="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="初识Docker"><a href="#初识Docker" class="headerlink" title="初识Docker"></a>初识Docker</h1><p>在我们平常部署项目的时候常常会面临组件多，运行环境复杂的问题，而这会导致：</p><ul><li>依赖关系复杂，出现兼容性问题</li><li>开发、测试、生产环境不一样的问题</li></ul><p>装过环境的小伙伴应该都知道这是一个多么烦人的过程，装上了还好说，装不上那就真的是白费心机，浪费时间。</p><p>这时，Docker给出了一个很好的解决方案：</p><p>1、解决大型项目依赖关系复杂，不同组件依赖的兼容性问题</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互隔离</li></ul><p>2、解决开发、测试、生产环境有差异的问题</p><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" class="" title="Docker概念"><h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" class="" title="Docker架构"><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 stable test 和 nightly 三个更新频道。</p><p>官方网站上有各种环境下的 安装指南，这里主要介绍 Docker CE 在 CentOS上的安装。</p><h3 id="CentOS安装Docker"><a href="#CentOS安装Docker" class="headerlink" title="CentOS安装Docker"></a>CentOS安装Docker</h3><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p><h3 id="卸载（可选）"><a href="#卸载（可选）" class="headerlink" title="卸载（可选）"></a>卸载（可选）</h3><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-selinux \</span><br><span class="line">    docker-engine-selinux \</span><br><span class="line">    docker-engine \</span><br><span class="line">    docker-ce</span><br></pre></td></tr></table></figure><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>首先需要大家虚拟机联网，安装yum工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">   device-mapper-persistent-data \</span><br><span class="line">   lvm2 --skip-broken</span><br></pre></td></tr></table></figure><p>更新XFS文件系统管理工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update xfsprogs -y</span><br></pre></td></tr></table></figure><p>然后更新本地镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置docker镜像源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决域名问题</span></span><br><span class="line">sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27;/etc/yum.repos.d/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新镜像源缓存</span></span><br><span class="line">yum makecache fast</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后输入命令</span></span><br><span class="line">yum install -y docker-ce</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一定要关闭防火墙后，再启动docker</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁止开机启动防火墙</span></span><br><span class="line">systemctl disablefirewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过命令启动docker：</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后输入命令，可以查看docker版本</span></span><br><span class="line">docker --version</span><br></pre></td></tr></table></figure><h3 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h3><p>docker官方镜像仓库网速较差，我们需要设置国内镜像：<br>参考阿里云的镜像加速文档：<br><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>总结</p><ul><li>什么是Docker：<br>  帮助我们快速构建应用镜像、交付应用、运行应用的技术</li><li>什么是镜像：<br>  将应用程序及其依赖、环境、配置打包在一起就是镜像</li><li>什么是容器：<br>  镜像运行起来就是容器，一个镜像可以运行多个容器</li><li>Docker工作流：<br>  构建自定义镜像或者从DockerRegistry拉取镜像<br>  根据镜像创建容器，并运行</li></ul><p>补充：<br>    Docker容器化虚拟化与传统虚拟机比较</p><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" class="" title="Docker容器化虚拟化与传统虚拟机比较"><h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><h2 id="Docker进程相关命令"><a href="#Docker进程相关命令" class="headerlink" title="Docker进程相关命令"></a>Docker进程相关命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动docker服务</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止docker服务</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启docker服务</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看docker服务状态</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置开机启动docker服务</span></span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><h2 id="Docker镜像相关命令"><a href="#Docker镜像相关命令" class="headerlink" title="Docker镜像相关命令"></a>Docker镜像相关命令</h2><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png" class="" title="Docker镜像相关命令"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看本地所有的镜像</span></span><br><span class="line">docker images</span><br><span class="line">docker images –q # 查看所镜像的id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从网络中查找需要的镜像</span></span><br><span class="line">docker search 镜像名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。 如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。</span></span><br><span class="line">docker pull 镜像名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除本地镜像</span></span><br><span class="line">docker rmi 镜像id # 删除指定本地镜像</span><br><span class="line">docker rmi `docker images -q` # 删除所有本地镜像</span><br></pre></td></tr></table></figure><h2 id="Docker容器相关命令"><a href="#Docker容器相关命令" class="headerlink" title="Docker容器相关命令"></a>Docker容器相关命令</h2><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.png" class="" title="Docker容器相关命令"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器</span></span><br><span class="line">docker ps # 查看正在运行的容器</span><br><span class="line">docker ps –a # 查看所有容器</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建并启动容器</span></span><br><span class="line">docker run 参数</span><br><span class="line"></span><br><span class="line">参数说明:</span><br><span class="line">• -i: 保持容器运行。通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。</span><br><span class="line">• -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用。</span><br><span class="line">• -d: 以守护(后台)模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭。</span><br><span class="line">• -it: 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器</span><br><span class="line">• --name: 为创建的容器命名。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以后台方式运行容器，并进入容器</span></span><br><span class="line">[root@hecs-33111 ~]# docker run-id --name=c2 redis:5.0 /bin/bash</span><br><span class="line">3842cee27f9b97fa7fb512aa53f835351f8860ffd5a4dc0e19b9e36d7aadf54</span><br><span class="line">[root@hecs-33111 ~]# docker exec-it c2 /bin/bash</span><br><span class="line">root@3842cee27f9b:/data# </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器</span></span><br><span class="line">docker exec 参数 # 退出容器，容器不会关闭</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器</span></span><br><span class="line">docker stop 容器名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动容器</span></span><br><span class="line">docker start 容器名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除容器</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果容器是运行状态则删除失败，需要停止容器才能删除</span></span><br><span class="line">docker rm 容器名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器信息</span></span><br><span class="line">docker inspect 容器名称</span><br></pre></td></tr></table></figure><h1 id="Docker容器的数据卷"><a href="#Docker容器的数据卷" class="headerlink" title="Docker容器的数据卷"></a>Docker容器的数据卷</h1><p>Docker容器中产生的数据本身也是保存在容器中的，所以删除容器的话容器中的数据也会一并被删除。还有些时候Docker容器之间或者和外部机器之间需要进行数据交互。</p><p>如果想要解决这两个问题就需要用到数据卷。</p><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.png" class="" title="Docker容器的数据卷"><h2 id="配置数据卷"><a href="#配置数据卷" class="headerlink" title="配置数据卷"></a>配置数据卷</h2><p>在创建容器时，使用-v参数设置数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ... –v 宿主机目录(文件):容器内目录(文件) ...</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>目录必须是绝对路径</li><li>如果目录不存在会自动创建</li><li>可以挂在多个数据卷，即容器A和容器B可以使用同一个数据卷</li></ul><p><strong>多个容器挂载一个数据卷</strong></p><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先创建启动容器c3并挂载数据卷</span></span><br><span class="line">docker run –it --name=c3 –v /volume centos:7 /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建启动 c1 c2 容器，使用 –-volumes-from 参数 设置数据卷</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用参数--volumes-from来达到与c3容器使用同一个数据卷的效果</span></span><br><span class="line">docker run –it --name=c1 --volumes-from c3 centos:7 /bin/bash </span><br><span class="line">docker run –it --name=c2 --volumes-from c3 centos:7 /bin/bash</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>数据卷概念</li></ol><ul><li>宿主机的一个目录或文件</li></ul><ol start="2"><li>数据卷作用</li></ol><ul><li>容器数据持久化</li><li>客户端和容器数据交换</li><li>容器间数据交换</li></ul><ol start="3"><li>数据卷容器</li></ol><ul><li>创建一个容器，挂载一个目录，让其他容器继承自该容器(–volume-from)。</li><li>通过简单方式实现数据卷配置</li></ul><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="Docker镜像原理"><a href="#Docker镜像原理" class="headerlink" title="Docker镜像原理"></a>Docker镜像原理</h2><p>经过以上几章的介绍，相信你已经对Docker有了更进一步的了解，如果还没有自己拉取过几个镜像并部署容器的话赶紧先去试试吧，如果已经尝试过了，那么你可能会发现：</p><ul><li>Docker中CentOS的镜像大小只有200m，但是操作系统的ISO却有几个G</li><li>一个Tomcat的安装包只有70m，但是Docker中拉取的镜像却有500m</li></ul><p>这就要涉及到Docker镜像的原理了，下面我们将展开对Docker镜像原理的介绍。</p><p>首先我们要了解一个操作系统的组成部分：</p><ul><li>进程调度子程序</li><li>进程通信子程序</li><li>内存管理子程序</li><li>设备管理子程序</li><li><strong>文件管理子程序</strong></li><li>网络通信子程序</li><li>作业控制子程序</li></ul><p>其中文件管理子系统</p><ol><li>rootfs: root文件系统，包含的就是典型 Linux 系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准目录和文件</li><li>bootfs: 加载引导程序(bootloader)+内核 (kernel)</li><li>不同的linux发行版本，bootfs基本一样，rootfs不同</li></ol><ul><li>Docker镜像是由特殊的文件系统叠加而成的</li><li>最低端是bootfs并使用宿主机的bootfs</li><li>第二层是root文件系统rootfs,称为base image</li><li>然后再往上可以参加其他系统的镜像文件</li><li>统一文件系统(Union File Svstem)技术能够将不同的层整合成一个文件系统，为这些层提供一个统一的视角，这样就隐藏了多层的存在，在用户的角度来看，只存在一个文件系统。</li><li>一个镜像可以放在另一个镜像的上面，位于下面的镜像称为父镜像，最底层的镜像称为基础镜像当从一个镜像启动容器的时候，Docker会在最顶层加载一个读写文件系统作为容器</li></ul><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.png" class="" title="Docker镜像原理"><h2 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a>镜像制作</h2><p>有两种方法：<br><strong>一、容器转为镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commit 容器id 镜像名称:版本号</span><br><span class="line">save -o 压缩文件名称 镜像名称:版本号</span><br><span class="line">load - 压缩文件名称</span><br></pre></td></tr></table></figure><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.png" class="" title="Docker镜像原理2"><p><strong>二、dockerfile</strong></p><ul><li>Dockerfile 是一个文本文件</li><li>包含了一条条的指令</li><li>每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像</li><li>对于开发人员：可以为开发团队提供一个完全一致的开发环境</li><li>对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了对于运维人员：在部署时，可以实现应用的无缝移植</li></ul><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.png" class="" title="dockerfile关键字1"><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.png" class="" title="dockerfile关键字2"><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>自定义一个 centos7镜像</p><ol><li>默认登录路径为&#x2F;usr</li><li>可以使用vim<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 步骤</span></span></span><br><span class="line">1. 定义一个父镜像 FROM centos:7</span><br><span class="line">2. 定义作者信息 MAINTAINER Shelton &lt;uli65535@gmail.com&gt;</span><br><span class="line">3. 执行安装vim的命令 RUN yum install -y vim</span><br><span class="line">4. 定义默认的工作目录WORKDIR /usr</span><br><span class="line">5. 定义容器的启动执行命令CMD /bin/bash</span><br></pre></td></tr></table></figure></li></ol><h1 id="Docker服务编排"><a href="#Docker服务编排" class="headerlink" title="Docker服务编排"></a>Docker服务编排</h1><p>微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，维护的工作量会很大</p><ul><li>要从Dockerfilebuildimage或者去dockerhub拉取image</li><li>要创建多个container</li><li>要管理这些container (启动停止删除)</li></ul><p>服务编排: 按照一定的业务规则批量管理容器</p><p>Docker Compose就是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建启动和停止。使用步骤:</p><ol><li>利用 Dockerfile定义运行环境镜像</li><li>使用docker-composeyml定义组成应用的各服务</li><li>运行 docker-composeup启动应用</li></ol><p><strong>安装Docker-Compose</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Compose目前已经完全支持Linux、Mac OS和Windows，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在我们安装Compose之前，需要先安装Docker</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面我们以编译好的二进制包方式安装在Linux系统中。</span> </span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置文件可执行权限</span> </span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看版本信息</span> </span><br><span class="line">docker-compose -version</span><br></pre></td></tr></table></figure><p><strong>卸载Docker Compose</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">二进制包方式安装的，删除二进制文件即可</span></span><br><span class="line">rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="案例：同时启动nginx和SpringBoot项目（已经创建为docker中的容器，名为app）"><a href="#案例：同时启动nginx和SpringBoot项目（已经创建为docker中的容器，名为app）" class="headerlink" title="案例：同时启动nginx和SpringBoot项目（已经创建为docker中的容器，名为app）"></a>案例：同时启动nginx和SpringBoot项目（已经创建为docker中的容器，名为app）</h3><p>1、创建docker-compose目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/docker-compose</span><br><span class="line">cd ~/docker-compose</span><br></pre></td></tr></table></figure><p>2、编写 docker-compose.yml 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">   image: nginx</span><br><span class="line">   ports:</span><br><span class="line">    - 80:80</span><br><span class="line">   links:</span><br><span class="line">    - app</span><br><span class="line">   volumes:</span><br><span class="line">    - ./nginx/conf.d:/etc/nginx/conf.d</span><br><span class="line">  app:</span><br><span class="line">    image: app</span><br><span class="line">    expose:</span><br><span class="line">      - &quot;8080&quot;</span><br></pre></td></tr></table></figure><p>3、创建.&#x2F;nginx&#x2F;conf.d目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ./nginx/conf.d</span><br></pre></td></tr></table></figure><p>4、在.&#x2F;nginx&#x2F;conf.d目录下 编写shelton.conf文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    access_log off;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://app:8080;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、在~&#x2F;docker-compose 目录下 使用docker-compose 启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p>6、测试访问</p><h1 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h1><p>Docker官方的Docker hub (<a href="https://hub.docker.com/">https://hub.docker.com</a>) 是一个用于管理公共镜像的仓库，我们可以从上面拉取镜像到本地，也可以把我们自己的镜像推送上去。但是，有时候我们的服务器无法访问互联网，或者你不希望将自己的镜像放到公网当中，那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像。</p><p>一、私有仓库搭建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1、拉取私有仓库镜像</span> </span><br><span class="line">docker pull registry</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2、启动私有仓库容器</span> </span><br><span class="line">docker run -id --name=registry -p 5000:5000 registry</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3、打开浏览器 输入地址http://私有仓库服务器ip:5000/v2/_catalog，看到&#123;<span class="string">&quot;repositories&quot;</span>:[]&#125; 表示私有仓库 搭建成功</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4、修改daemon.json</span>   </span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器ip修改为自己私有仓库服务器真实ip</span> </span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;私有仓库服务器ip:5000&quot;]&#125; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5、重启docker 服务</span> </span><br><span class="line">systemctl restart docker</span><br><span class="line">docker start registry</span><br></pre></td></tr></table></figure><p>二、将镜像上传至私有仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1、标记镜像为私有仓库的镜像</span>     </span><br><span class="line">docker tag centos:7 私有仓库服务器IP:5000/centos:7</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2、上传标记的镜像</span>     </span><br><span class="line">docker push 私有仓库服务器IP:5000/centos:7</span><br></pre></td></tr></table></figure><p>三、 从私有仓库拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拉取镜像</span> </span><br><span class="line">docker pull 私有仓库服务器ip:5000/centos:7</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
