<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式</title>
      <link href="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景-🚀"><a href="#0-背景-🚀" class="headerlink" title="0. 背景 🚀"></a><strong>0. 背景 🚀</strong></h1><p>当Java开发快一年了，设计模式这门必修居然忘得差不多了，有点离谱，有点惭愧，有点遗憾。</p><p>今下决心，将其重新拾起，故作此笔记以记录学习过程，便于日后再再拾起（手动狗头</p><h1 id="1-设计模式全局概览-🚀"><a href="#1-设计模式全局概览-🚀" class="headerlink" title="1. 设计模式全局概览 🚀"></a><strong>1. 设计模式全局概览 🚀</strong></h1><h2 id="1-1-知识来源"><a href="#1-1-知识来源" class="headerlink" title="1.1 知识来源"></a><em>1.1 知识来源</em></h2><hr><ol><li>作为BiliBili大学黑马老师教出来的程序员，自然还是首选黑马：<a href="https://www.bilibili.com/video/BV1Np4y1z7BU">https://www.bilibili.com/video/BV1Np4y1z7BU</a></li><li>同事分享的PDF：《您的设计模式》—— CBF4LIFE</li><li>网络</li></ol><h2 id="1-2-为什么需要学"><a href="#1-2-为什么需要学" class="headerlink" title="1.2 为什么需要学"></a><em>1.2 为什么需要学</em></h2><hr><ul><li>提高程序员的思维能力（即让我们的思维更加开阔，如果后期我们要去设计咱们的软件的话，那么就能套用这些设计模式去设计咱们的软件了）、编程能力和设计能力。当然，在这里我们更强调的是设计能力</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强</li></ul><h2 id="1-3-设计模式的分类"><a href="#1-3-设计模式的分类" class="headerlink" title="1.3 设计模式的分类"></a><em>1.3 设计模式的分类</em></h2><hr><p>23种设计模式分为三大类型：</p><ul><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul><h3 id="1-3-1-创建型模式-📌"><a href="#1-3-1-创建型模式-📌" class="headerlink" title="1.3.1 创建型模式 📌"></a>1.3.1 创建型模式 📌</h3><p>创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。<strong>简单地说就是用于描述”怎样创建对象”，它的主要特点是”将对象的创建与使用分离”，将创建和使用解耦。</strong></p><p>创建型模式包含了：</p><div style="list-style-type: decimal;padding-left: 20px;border: 1px solid #ddd;background-color: #f9f9f9;border-radius: 5px;margin: 0;">    <li style="margin-bottom: 10px;">工厂模式</li>    <li style="margin-bottom: 10px;">抽象工厂模式</li>    <li style="margin-bottom: 10px;">单例模式</li>    <li style="margin-bottom: 10px;">建造者模式</li>    <li style="margin-bottom: 10px;">原型模式</li></div><h3 id="1-3-2-结构型模式-📌"><a href="#1-3-2-结构型模式-📌" class="headerlink" title="1.3.2 结构型模式 📌"></a>1.3.2 结构型模式 📌</h3><p>结构型模式用于描述如何将类和对象按照某种布局组成更大的结构。结构型模式关注类和对象的组合，继承的概念被用来组合接口和定义组合对象获得新功能的方式。<br>例子：比如说，你现在要盖房，那么<strong>创建型模式就好比你去购买盖房所需要的材料，如钢筋、水泥等等，然后用这些材料你就能搭起来整个房屋的架构了，这个就是所谓的结构型模式。</strong></p><p>结构型模式包含了：</p><div style="list-style-type: decimal;padding-left: 20px;border: 1px solid #ddd;background-color: #f9f9f9;border-radius: 5px;margin: 0;">    <li style="margin-bottom: 10px;">适配器模式</li>    <li style="margin-bottom: 10px;">装饰器模式</li>    <li style="margin-bottom: 10px;">代理模式</li>    <li style="margin-bottom: 10px;">外观模式</li>    <li style="margin-bottom: 10px;">桥接模式</li>    <li style="margin-bottom: 10px;">组合模式</li>    <li style="margin-bottom: 10px;">享元模式</li></div><h3 id="1-3-3-行为型模式-📌"><a href="#1-3-3-行为型模式-📌" class="headerlink" title="1.3.3 行为型模式 📌"></a>1.3.3 行为型模式 📌</h3><p>用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责，<strong>它们特别关注对象之间的通信，也就是说多个对象合作去完成某一件事。</strong></p><p>行为型模式包含了：</p><div style="list-style-type: decimal;padding-left: 20px;border: 1px solid #ddd;background-color: #f9f9f9;border-radius: 5px;margin: 0;">    <li style="margin-bottom: 10px;">策略模式</li>    <li style="margin-bottom: 10px;">模板方法模式</li>    <li style="margin-bottom: 10px;">观察者模式</li>    <li style="margin-bottom: 10px;">迭代子模式</li>    <li style="margin-bottom: 10px;">责任链模式</li>    <li style="margin-bottom: 10px;">命令模式</li>    <li style="margin-bottom: 10px;">备忘录模式</li>    <li style="margin-bottom: 10px;">状态模式</li>    <li style="margin-bottom: 10px;">访问者模式</li>    <li style="margin-bottom: 10px;">中介者模式</li>    <li style="margin-bottom: 10px;">解释器模式</li></div><h2 id="1-4-六大设计原则"><a href="#1-4-六大设计原则" class="headerlink" title="1.4 六大设计原则"></a><em>1.4 六大设计原则</em></h2><hr><p>在软件开发中，<strong>为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，</strong>程序员要尽量根据6条原则来开发程序，<strong>从而提高软件开发效率、节约软件开发成本和维护成本。</strong><br>六大原则分别是：</p><div style="list-style-type: decimal;padding-left: 20px;border: 1px solid #ddd;background-color: #f9f9f9;border-radius: 5px;margin: 0;">    <li style="margin-bottom: 10px;">单一职责原则</li>    <li style="margin-bottom: 10px;">里氏代换原则</li>    <li style="margin-bottom: 10px;">依赖倒转原则</li>    <li style="margin-bottom: 10px;">接口隔离原则</li>    <li style="margin-bottom: 10px;">迪米法特原则</li>    <li style="margin-bottom: 10px;">开闭原则</li></div><h1 id="2-设计原则-🚀"><a href="#2-设计原则-🚀" class="headerlink" title="2.设计原则 🚀"></a><strong>2.设计原则 🚀</strong></h1><h2 id="2-1-单一职责原则"><a href="#2-1-单一职责原则" class="headerlink" title="2.1 单一职责原则"></a><em>2.1 单一职责原则</em></h2><hr><p><strong>首先来一个自我总结：</strong></p><p>一个类应该只负责一项职责，这样可以降低类的复杂度，类的功能就比较单一，容易理解，容易维护。<br>在一开始开发的时候就做好单一职责，在以后需要更改类当中某个功能的时候只需要修改对应职责的接口，不会影响到别的功能。</p><p><strong>优点：</strong></p><ul><li><strong>类的复杂性降低</strong>，实现什么职责都有清晰明确的定义； </li><li><strong>可读性提高</strong>，复杂性降低，那当然可读性提高了； </li><li><strong>可维护性提高</strong>，那当然了，可读性提高，那当然更容易维护了；</li><li><strong>变更引起的风险降低</strong>，变更是必不可少的，接口的单一职责做的好的话，一个接口修改只对相应的实现类有影响，与其他的接口无影响，这个是对项目有非常大的帮助</li></ul><h2 id="2-2-里氏替换原则"><a href="#2-2-里氏替换原则" class="headerlink" title="2.2 里氏替换原则"></a><em>2.2 里氏替换原则</em></h2><hr><p>请看：<a href="https://blog.csdn.net/weixin_39327556/article/details/125268590">https://blog.csdn.net/weixin_39327556&#x2F;article&#x2F;details&#x2F;125268590</a></p><p><strong>自我总结：</strong><br>里氏代换原则是指任何基类可以出现的地方，子类一定可以出现，不会发生异常。<strong>可以通俗理解成子类可以扩展父类的功能，但不能改变父类原有的功能。</strong></p><p><strong>优点：</strong><br>里氏替换法则诞生的目的就是<strong>加强程序的健壮性</strong>，同时<em>版本升级</em>也可以做到非常好的<strong>兼容性</strong>，增加子类，原有的子类还可以继续运行。在我们项目实施中就是每个子类对应了不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常完美！</p><h2 id="2-3-依赖倒转原则"><a href="#2-3-依赖倒转原则" class="headerlink" title="2.3 依赖倒转原则"></a><em>2.3 依赖倒转原则</em></h2><hr><div style="list-style-type: decimal;padding-left: 20px;border: 1px solid #ddd;background-color: #f9f9f9;border-radius: 5px;margin: 0;">高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</div><p>例子：</p><img src="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE1.png" class="" title="电脑及其硬件"><p>如果像这样设计类的话，往后如果想要换硬件还得修改computer类，所以我们将硬件的基本功能写进接口里面，让具体的硬件类去实现这种方法，然后在使用computer类的时候在去创建具体的硬件类，这样computer类就只负责显示，而不管具体是什么硬件。如下图所示。</p><img src="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE2.png" class="" title="电脑及其硬件2"><h2 id="2-4-接口隔离原则"><a href="#2-4-接口隔离原则" class="headerlink" title="2.4 接口隔离原则"></a><em>2.4 接口隔离原则</em></h2><hr><p>接口隔离原则是指客户端不应该被迫依赖于它不使用的方法，一个类对另一个类的依赖应该建立在最小的接口上面。</p><img src="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%991.png" class="" title="接口隔离原则1"><p>我们改造一下：</p><img src="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%992.png" class="" title="接口隔离原则2"><h2 id="2-5-迪米特法则"><a href="#2-5-迪米特法则" class="headerlink" title="2.5 迪米特法则"></a><em>2.5 迪米特法则</em></h2><hr><p>也叫最少知识原则<br>解释起来也很简单：是自己的就是自己的。在项目中有一些方法，<strong>放在本类中也可以</strong>，放在<strong>其他类中也没有错误</strong>，那怎么去衡量呢？你可以坚持这样一个原则：<strong>如果一个方法放在本类中，即不增加类间关系，也对本类不产生负面影响，就放置在本类中。</strong></p><h2 id="2-6-开闭原则"><a href="#2-6-开闭原则" class="headerlink" title="2.6 开闭原则"></a><em>2.6 开闭原则</em></h2><hr><p>软件实体（模块、类、方法等）应该对扩展开放、对修改关闭：添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）</p><p>这里有几个好例子：<a href="https://zhuanlan.zhihu.com/p/641331256">https://zhuanlan.zhihu.com/p/641331256</a></p><h1 id="3-设计模式-🚀"><a href="#3-设计模式-🚀" class="headerlink" title="3.设计模式 🚀"></a><strong>3.设计模式 🚀</strong></h1><h2 id="3-1-创建型模式"><a href="#3-1-创建型模式" class="headerlink" title="3.1 创建型模式"></a><em>3.1 创建型模式</em></h2><hr><h3 id="3-1-1-工厂模式-📌"><a href="#3-1-1-工厂模式-📌" class="headerlink" title="3.1.1 工厂模式 📌"></a>3.1.1 工厂模式 📌</h3><ul><li>在java中，万物皆对象，这些对象都需要创建，<strong>如果创建的时候直接new该对象</strong>，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，<strong>这显然违背了软件设计的开闭原则</strong>。</li><li>如果我们使用工厂来生产对象，我们就<strong>只和工厂打交道就可以了</strong>，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的。</li><li>所以说，工厂模式最大的优点就是：<strong>解耦</strong>。</li></ul><h4 id="3-1-1-1-简单工厂模式"><a href="#3-1-1-1-简单工厂模式" class="headerlink" title="3.1.1.1 简单工厂模式"></a>3.1.1.1 简单工厂模式</h4><p>原始例子看下图：</p><img src="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82-%E5%8E%9F%E5%A7%8B.png" class="" title="简单工厂-原始"><p><strong>接下来我们要将其改造为简单工厂模式</strong><br>简单工厂包含如下角色：<br><strong>抽象产品</strong> ：定义了产品的规范，描述了产品的主要特性和功能。<br><strong>具体产品</strong> ：实现或者继承抽象产品的子类<br><strong>具体工厂</strong> ：提供了创建产品的方法，调用者通过该方法来获取产品。</p><p>改造后：</p><img src="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82-%E6%94%B9%E9%80%A0%E5%90%8E.png" class="" title="简单工厂-改造后"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.pattern.factory.factory_simple;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单咖啡工厂类，用来生产咖啡</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 简单工厂处理创建对象的细节，有了此简单工厂对象，在CoffeeStore对象中如果需要Coffee对象，只需要在工厂类</span></span><br><span class="line"><span class="comment"> * 中获取就行。这样解除了Coffee类和CoffeeStore类的耦合，但是这样也产生了新的耦合，即工厂对象和CoffeeStore</span></span><br><span class="line"><span class="comment"> * 的耦合以及工厂对象跟Coffee类的耦合。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 有了工厂对象，如果后期增加了更多的咖啡，则势必对工厂对象进行改造，违反了开闭原则。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 简单工厂：</span></span><br><span class="line"><span class="comment"> * 优点：</span></span><br><span class="line"><span class="comment"> * 封装了创建对象的细节，可以通过参数直接获取对象，把对象的创建和业务逻辑层分开，这样避免以后修改客户端代码，</span></span><br><span class="line"><span class="comment"> * 如果要实现新的产品，直接修改工厂类就行了，而不需要在业务代码中修改，这样就降低了客户代码修改的可能性，更加</span></span><br><span class="line"><span class="comment"> * 容易扩展。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 缺点：</span></span><br><span class="line"><span class="comment"> * 增加新的产品的时候，还是需要修改工厂类，违背了设计原则的开闭原则。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="comment">//声明Coffee类型的变量，根据不同的类型创建不同的coffee子类对象</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;american&quot;</span>.equals(type))&#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type))&#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;对不起，您点的咖啡没有&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将创建方法定义为静态方法，就是所谓的静态工厂模式，但是其实不属于23种设计模式。</p><h4 id="3-1-1-2-工厂方法模式"><a href="#3-1-1-2-工厂方法模式" class="headerlink" title="3.1.1.2 工厂方法模式"></a>3.1.1.2 工厂方法模式</h4><p>看过了简单工厂模式，接下来我们看看工厂方法模式。<br>原理：<strong>将创建实例的过程延迟到子类中，从而实现对创建实例的解耦</strong>。</p><p>工厂方法模式的主要角色：<br><strong>抽象工厂（Abstract Factory）</strong>：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。<br><strong>具体工厂（ConcreteFactory）</strong>：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。<br><strong>抽象产品（Product）</strong>：定义了产品的规范，描述了产品的主要特性和功能。<br><strong>具体产品（ConcreteProduct）</strong>：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</p><p>如图所示：</p><img src="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" class="" title="工厂模式"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.pattern.factory.factory_method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂：如果增加新的种类咖啡，只需要增加一个CoffeeFactory接口的实现类就行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 优点：</span></span><br><span class="line"><span class="comment"> * - 用户只需要知道具体的工厂名字就能得到所需要的产品，无需知道产品的具体创建过程</span></span><br><span class="line"><span class="comment"> * - 在系统增加新的产品时只需要添加具体产品类对应的具体工厂类，无需对原工厂类进行任何修改，满足开闭原则</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 缺点：</span></span><br><span class="line"><span class="comment"> * - 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CoffeeFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFactory</span><span class="params">(CoffeeFactory factory)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> factory.createCoffee();</span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addSugar();</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-抽象工厂模式-📌"><a href="#3-1-2-抽象工厂模式-📌" class="headerlink" title="3.1.2 抽象工厂模式 📌"></a>3.1.2 抽象工厂模式 📌</h3><p>和工厂模式一样，但是抽象工厂模式可以生产多个产品族，就好像比亚迪可以造车也可以生产口罩一样。<br>如图所示：</p><img src="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E4%BA%A7%E5%93%81%E6%97%8F.png" class="" title="抽象工厂-产品族"><p>抽象工厂模式的主要角色如下：<br><strong>抽象工厂（Abstract Factory）</strong>：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。<br><strong>具体工厂（Concrete Factory）</strong>：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。<br><strong>抽象产品（Product）</strong>：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。<br><strong>具体产品（ConcreteProduct）</strong>：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</p><p>将上面的工厂模式改造成如下图就成了抽象工厂模式：</p><img src="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.png" class="" title="抽象工厂"><div style="list-style-type: decimal;padding-left: 20px;border: 1px solid #ddd;background-color: #f9f9f9;border-radius: 5px;margin: 0;">优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。<p>缺点：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p></div><h3 id="3-1-3-单例模式-📌"><a href="#3-1-3-单例模式-📌" class="headerlink" title="3.1.3 单例模式 📌"></a>3.1.3 单例模式 📌</h3><p>单例模式：<strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点</strong>。</p><h4 id="3-1-3-1-饿汉式"><a href="#3-1-3-1-饿汉式" class="headerlink" title="3.1.3.1 饿汉式"></a>3.1.3.1 饿汉式</h4><p><strong>饿得不行，不等你了，先吃饱再说</strong></p><p><strong>第一种方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式：预加载</span></span><br><span class="line"><span class="comment"> * 静态成员变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line">    <span class="comment">//定义静态成员变量获取本类的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton1</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法，避免通过new关键字来实例化对象，保证只存在一个实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个公共的访问类，让外界获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getINSTANCE</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式的第二种实现方式：</span></span><br><span class="line"><span class="comment"> * 使用静态代码块的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明Singleton2类型的静态常量成员变量，但是没有初始化，在静态代码块中对其进行初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton2 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在静态代码块中对成员常量初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有化构造方法，避免外部使用new关键字创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义公共方法，对外提供获取单例实例的接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getINSTANCE</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，不管我们使不使用，这个单例对象都会在类加载的时候就创建出来，可能会浪费内存空间。</p><h4 id="3-1-3-2-懒汉式"><a href="#3-1-3-2-懒汉式" class="headerlink" title="3.1.3.2 懒汉式"></a>3.1.3.2 懒汉式</h4><p><strong>不催我我都懒得起床吃饭（第一次被真正使用时才加载）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基础</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstanceL</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进阶</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstanceM1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstanceM2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 高手</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstanceH</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 线程A或线程B获得该锁进行初始化</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是由于存在代码重排的问题，详见：<a href="https://blog.csdn.net/t13220621385/article/details/134375665">https://blog.csdn.net/t13220621385/article/details/134375665</a><br>所以我们需要使用violatile关键字来防止重排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//这里加上了volatile关键字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用双重检查解决了单例、性能、线程安全问题，但是在多线程环境中由于JVM在实例化对象的时候会进行</span></span><br><span class="line"><span class="comment">         * 优化和指令的重排序操作，可能会导致空指针异常问题，这时候需要使用volatile关键字，可以保证可见性</span></span><br><span class="line"><span class="comment">         * 和有序性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// 线程A或线程B获得该锁进行初始化</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123; </span><br><span class="line">                <span class="comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123; </span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了以上的懒汉，还有一种静态内部类实现懒汉的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式方式4，静态内部类方式</span></span><br><span class="line"><span class="comment"> * 静态内部类单例模式中实例由内部类创建，由于JVM在加载外部内的过程中，是不会加载静态内部类的，只有内部类 的属性或者方法被调用时，才会被加载，并初始化其静态属性。静态属性由于被static修饰，所以只会被实例化一次， 并且严格保证实例化顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton5</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义静态内部类，私有化属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton5</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton5</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-3-3-枚举式"><a href="#3-1-3-3-枚举式" class="headerlink" title="3.1.3.3 枚举式"></a>3.1.3.3 枚举式</h4><p>懒汉和饿汉的单例是可以被破坏的：</p><ol><li>利用反射<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取类的显式构造器</span></span><br><span class="line">    Constructor&lt;Singleton&gt; construct = Singleton.class.getDeclaredConstructor();</span><br><span class="line">    <span class="comment">// 可访问私有构造器</span></span><br><span class="line">    construct.setAccessible(<span class="literal">true</span>); </span><br><span class="line">    <span class="comment">// 利用反射构造新对象</span></span><br><span class="line">    <span class="type">Singleton</span> <span class="variable">obj1</span> <span class="operator">=</span> construct.newInstance(); </span><br><span class="line">    <span class="comment">// 通过正常方式获取单例对象</span></span><br><span class="line">    <span class="type">Singleton</span> <span class="variable">obj2</span> <span class="operator">=</span> Singleton.getInstance(); </span><br><span class="line">    System.out.println(obj1 == obj2); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>利用序列化与反序列化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建输出流</span></span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Singleton.file&quot;</span>));</span><br><span class="line">    <span class="comment">// 将单例对象写到文件中</span></span><br><span class="line">    oos.writeObject(Singleton.getInstance());</span><br><span class="line">    <span class="comment">// 从文件中读取单例对象</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Singleton.file&quot;</span>);</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">    <span class="type">Singleton</span> <span class="variable">newInstance</span> <span class="operator">=</span> (Singleton) ois.readObject();</span><br><span class="line">    <span class="comment">// 判断是否是同一个对象</span></span><br><span class="line">    System.out.println(newInstance == Singleton.getInstance()); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>为了解决上面两个问题，可以使用以下两个方法：</p><ol><li><p>构造方法中增加判断，解决反射破坏单例的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化构造器</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在构造方法中增加判断，解决反射破坏单例的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton5</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton5.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="comment">//判断flag的值，如果是true，说明是第一次访问，如果不是，说明是第一次访问。</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不能创建两个对象&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将flag的值设置为true</span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton5</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton5</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举类实现单例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （1）Enum 类内部使用Enum 类型判定防止通过反射创建多个对象</span></span><br><span class="line"><span class="comment"> * （2）Enum 类通过写出（读入）对象类型和枚举名字将对象序列化（反序列化），通过 valueOf() 方法匹配枚举名找到内存中的唯一的对象实例，防止通过反序列化构造多个对象</span></span><br><span class="line"><span class="comment"> * （3）枚举类不需要关注线程安全、破坏单例和性能问题，因为其创建对象的时机与饿汉式单例有异曲同工之妙。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE(<span class="number">123</span>, <span class="string">&quot;ABC&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    Singleton(Integer id, String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Singleton</span> <span class="variable">t1</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">    t1.setName(<span class="string">&quot;DEF&quot;</span>);</span><br><span class="line">    <span class="type">Singleton</span> <span class="variable">t2</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">    t2.setName(<span class="string">&quot;XYZ&quot;</span>);</span><br><span class="line">    System.out.println(t1);</span><br><span class="line">    System.out.println(t2);</span><br><span class="line">    System.out.print(t1 == t2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    结果：</span></span><br><span class="line"><span class="comment">        Singleton&#123;id=123,name=&#x27;XYZ&#x27;&#125;</span></span><br><span class="line"><span class="comment">        Singleton&#123;id=123,name=&#x27;XYZ&#x27;&#125;</span></span><br><span class="line"><span class="comment">        true</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-1-4-建造者模式-📌"><a href="#3-1-4-建造者模式-📌" class="headerlink" title="3.1.4 建造者模式 📌"></a>3.1.4 建造者模式 📌</h3><p><strong>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</strong></p><p><strong>建造者模式的各个角色：</strong></p><ul><li><strong>抽象建造者类（Builder）</strong>：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。</li><li><strong>具体建造者类（ConcreteBuilder）</strong>：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。</li><li><strong>产品类（Product）</strong>：要创建的复杂对象。</li><li><strong>指挥者类（Director）</strong>：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</li></ul><img src="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.png" class="" title="建造者模式"><p><strong>应用场景：</strong><br>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p><ul><li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li><li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li></ul><p><strong>例子：</strong></p><img src="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-%E4%BE%8B%E5%AD%90.png" class="" title="建造者模式-例子"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自行车类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bike</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String frame;</span><br><span class="line">    <span class="keyword">private</span> String seat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFrame</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> frame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFrame</span><span class="params">(String frame)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.frame = frame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSeat</span><span class="params">(String seat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seat = seat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象 builder 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Bike</span> <span class="variable">mBike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bike</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Bike <span class="title function_">createBike</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//摩拜单车Builder类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MobikeBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span> &#123;</span><br><span class="line">        mBike.setFrame(<span class="string">&quot;铝合金车架&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span> &#123;</span><br><span class="line">        mBike.setSeat(<span class="string">&quot;真皮车座&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bike <span class="title function_">createBike</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mBike;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ofo单车Builder类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OfoBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span> &#123;</span><br><span class="line">        mBike.setFrame(<span class="string">&quot;碳纤维车架&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span> &#123;</span><br><span class="line">        mBike.setSeat(<span class="string">&quot;橡胶车座&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bike <span class="title function_">createBike</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mBike;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指挥者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Builder mBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        mBuilder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bike <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        mBuilder.buildFrame();</span><br><span class="line">        mBuilder.buildSeat();</span><br><span class="line">        <span class="keyword">return</span> mBuilder.createBike();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        showBike(<span class="keyword">new</span> <span class="title class_">OfoBuilder</span>());</span><br><span class="line">        showBike(<span class="keyword">new</span> <span class="title class_">MobikeBuilder</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showBike</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(builder);</span><br><span class="line">        <span class="type">Bike</span> <span class="variable">bike</span> <span class="operator">=</span> director.construct();</span><br><span class="line">        System.out.println(bike.getFrame());</span><br><span class="line">        System.out.println(bike.getSeat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>优缺点：</strong></p><blockquote><p><strong>优：</strong></p></blockquote><ul><li>建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</li><li>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li>建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。</li></ul><blockquote><p><strong>缺：</strong></p></blockquote><ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li></ul><h3 id="3-1-5-原型模式-📌"><a href="#3-1-5-原型模式-📌" class="headerlink" title="3.1.5 原型模式 📌"></a>3.1.5 原型模式 📌</h3><blockquote><p>通过复制现有实例来创建新的实例，无需知道相应类的信息。用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。（复制一个一模一样但是是一个新对象）</p></blockquote><p><strong>角色：</strong></p><ul><li>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ul><p><strong>拷贝类型：</strong></p><ul><li><p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</p><blockquote><p>Java中的Object类中提供了 clone() 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxg.pattern.prototype.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Realizetype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Realizetype</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体的原型对象创建完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写超级父类Object提供的clone()方法，实现浅克隆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Realizetype <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型复制成功！&quot;</span>);</span><br><span class="line">        <span class="comment">// 对象不是同一个，但是对象中的属性值是同一个</span></span><br><span class="line">        <span class="keyword">return</span> (Realizetype) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景：</p><ul><li>对象的创建非常复杂，可以使用原型模式快捷的创建对象。</li><li>性能和安全要求比较高。</li></ul></blockquote></li><li><p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citation</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Citation <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line">        c1.setStu(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制奖状</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> c1.clone();</span><br><span class="line">        <span class="comment">//获取c2奖状所属学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> c2.getStu();</span><br><span class="line">        stu1.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断stu对象和stu1对象是否是同一个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            stu和stu1是同一个对象？true</span></span><br><span class="line"><span class="comment">            李四同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！</span></span><br><span class="line"><span class="comment">            李四同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       运行结果表明，使用Object提供的clone()方法实现的是对象的浅克隆</span></span><br><span class="line"><span class="comment">        stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用对象流。代码如下面的main</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Citation类和Student类必须实现Serializable接口，否则会抛NotSerializableException异常。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        c1.setStu(stu1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象输出流对象</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//将c1对象写出到文件中</span></span><br><span class="line">        oos.writeObject(c1);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象出入流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//读取对象</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> (Citation) ois.readObject();</span><br><span class="line">        <span class="comment">//从c2获取student对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> c2.getStu();</span><br><span class="line">        stu2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断stu对象和stu1对象是否是同一个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;stu1和stu2是同一个对象？&quot;</span>+(stu1==stu2));</span><br><span class="line">        </span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            stu1和stu2是同一个对象？false</span></span><br><span class="line"><span class="comment">            张三同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！</span></span><br><span class="line"><span class="comment">            李四同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景：</p><ul><li>对象的创建非常复杂，可以使用原型模式快捷的创建对象。</li><li>性能和安全要求比较高。</li></ul></blockquote></li></ul><h2 id="3-2-结构型模式"><a href="#3-2-结构型模式" class="headerlink" title="3.2 结构型模式"></a><em>3.2 结构型模式</em></h2><hr><h3 id="3-2-1-适配器模式-📌"><a href="#3-2-1-适配器模式-📌" class="headerlink" title="3.2.1 适配器模式 📌"></a>3.2.1 适配器模式 📌</h3><blockquote><p>适配器，平常生活中最常见的就是转接口<br><strong>定义：</strong><br>将一个类的接口转换成<strong>客户希望的另外一个接口</strong>，使得原本由于接口<strong>不兼容而不能一起工作</strong>的那些类<strong>能一起工作</strong>。</p></blockquote><blockquote><p><strong>角色：</strong></p><ul><li><strong>目标（Target）接口：</strong>当前系统业务所期待的接口，它可以是抽象类或接口。</li><li><strong>适配者（Adaptee）类：</strong>它是被访问和适配的现存组件库中的组件接口。</li><li><strong>适配器（Adapter）类：</strong>它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ul></blockquote><p><strong>类适配器：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SD卡的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="comment">//读取SD卡方法</span></span><br><span class="line">    String <span class="title function_">readSD</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入SD卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SD卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;sd card read a msg :hello word SD&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sd card write msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">(SDCard sdCard)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sdCard == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;sd card null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sdCard.readSD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TFCard</span> &#123;</span><br><span class="line">    <span class="comment">//读取TF卡方法</span></span><br><span class="line">    String <span class="title function_">readTF</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入TF卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">TFCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readTF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span><span class="string">&quot;tf card read msg : hello word tf card&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tf card write a msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义适配器类（SD兼容TF）</span></span><br><span class="line"><span class="comment">// 实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span> <span class="keyword">extends</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> readTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);</span><br><span class="line">        writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">SDCard</span> <span class="variable">sdCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDCardImpl</span>();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>();</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。</span></span><br></pre></td></tr></table></figure><p><strong>对象适配器模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在类适配器的基础上修改适配器类和测试类。</span></span><br><span class="line"><span class="comment">// 创建适配器对象（SD兼容TF）</span></span><br><span class="line"><span class="comment">// 对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span>  <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TFCard tfCard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tfCard = tfCard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tfCard.readTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);</span><br><span class="line">        tfCard.writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">SDCard</span> <span class="variable">sdCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDCardImpl</span>();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">TFCard</span> <span class="variable">tfCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TFCardImpl</span>();</span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>(tfCard);</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>适用情况：</strong></p><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li></ul></blockquote><h3 id="3-3-2-装饰器模式-📌"><a href="#3-3-2-装饰器模式-📌" class="headerlink" title="3.3.2 装饰器模式 📌"></a>3.3.2 装饰器模式 📌</h3><p><strong>结构：</strong></p><blockquote><p><strong>抽象构件（Component）角色：</strong>定义一个抽象接口以规范准备接收附加责任的对象。<br><strong>具体构件（Concrete Component）角色：</strong>实现抽象构件，通过装饰角色为其添加一些职责。<br><strong>抽象装饰（Decorator）角色：</strong>继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。<br><strong>具体装饰（ConcreteDecorator）角色：</strong>实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快餐接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> price;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastFood</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastFood</span><span class="params">(<span class="type">float</span> price, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">float</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDesc</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span>;  <span class="comment">//获取价格</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒饭</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRice</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedRice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">10</span>, <span class="string">&quot;炒饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedNoodles</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedNoodles</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">12</span>, <span class="string">&quot;炒面&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配料类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Garnish</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FastFood fastFood;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> FastFood <span class="title function_">getFastFood</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFastFood</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Garnish</span><span class="params">(FastFood fastFood, <span class="type">float</span> price, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(price,desc);</span><br><span class="line">        <span class="built_in">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鸡蛋配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Egg</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Egg</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(fastFood,<span class="number">1</span>,<span class="string">&quot;鸡蛋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//培根配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bacon</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bacon</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(fastFood,<span class="number">2</span>,<span class="string">&quot;培根&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//点一份炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">&quot; &quot;</span> + food.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">//点一份加鸡蛋的炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line"></span><br><span class="line">        food1 = <span class="keyword">new</span> <span class="title class_">Egg</span>(food1);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food1.getDesc() + <span class="string">&quot; &quot;</span> + food1.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">//点一份加培根的炒面</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedNoodles</span>();</span><br><span class="line">        food2 = <span class="keyword">new</span> <span class="title class_">Bacon</span>(food2);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food2.getDesc() + <span class="string">&quot; &quot;</span> + food2.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景：</strong></p><blockquote><ul><li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。<br>  不能采用继承的情况主要有两类：<br>  第一类 是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长<br>  第二类 是因为类定义不能继承（如final类）</li><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</li></ul></blockquote><p><strong>优点：</strong></p><blockquote><ul><li>饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。</li><li>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</li></ul></blockquote><p><strong>缺点：</strong></p><blockquote><ul><li>扩展性不好</li><li>如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。</li></ul></blockquote><h3 id="3-3-3-代理模式-📌"><a href="#3-3-3-代理模式-📌" class="headerlink" title="3.3.3 代理模式 📌"></a>3.3.3 代理模式 📌</h3><p>代理模式：为其他对象提供一种代理以控制对这个对象的访问。（直观的说，代理就是生产厂商和消费者之间的中介，消费者想买都是去找中介）（1688警告）</p><blockquote><p>Java中的代理按照代理类生成时机不同又分为<strong>静态代理</strong>和<strong>动态代理</strong><br>  <strong>静态代理代理类</strong>在编译期就生成，<br>  <strong>动态代理代理类</strong>则是在Java运行时动态生成，动态代理又有JDK代理和CGLib代理两种。</p></blockquote><p><strong>结构：</strong></p><ul><li><strong>抽象主题（Subject）类</strong>： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li><li><strong>真实主题（Real Subject）类</strong>： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li><li><strong>代理（Proxy）类</strong> ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 卖票接口，定义卖票规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sell.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 火车站类，具有卖票功能，所以需要实现接口SellTickets</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代售点，将火车站卖票的功能拿到代售点来，即代售点可以卖出火车票，具有</span></span><br><span class="line"><span class="comment"> * 卖票功能，所以需要实现SellTickets接口，同时是代理火车站卖票，即车票</span></span><br><span class="line"><span class="comment"> * 与火车站有关联，表现为具有属性 “火车站”</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPoint</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrainStation station;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点代售火车票，收取一定的代理费&quot;</span>);</span><br><span class="line">        station.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyPoint</span> <span class="variable">proxyPoint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPoint</span>();</span><br><span class="line">        proxyPoint.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。</span></span><br></pre></td></tr></table></figure><h4 id="3-3-3-1-JDK动态代理"><a href="#3-3-3-1-JDK动态代理" class="headerlink" title="3.3.3.1 JDK动态代理"></a>3.3.3.1 JDK动态代理</h4><blockquote><p>Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 卖票接口，定义卖票规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sell.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 火车站类，具有卖票功能，所以需要实现接口SellTickets</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理工厂，用来创建代理对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理工厂，动态获取代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用Proxy代理类中的newProxyInstance方法来动态获取代理对象</span></span><br><span class="line"><span class="comment">         * newProxyInstance()方法参数说明：</span></span><br><span class="line"><span class="comment">         *  ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可</span></span><br><span class="line"><span class="comment">         *  Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口</span></span><br><span class="line"><span class="comment">         *  InvocationHandler h ： 代理对象的调用处理程序</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">sellTickets</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(</span><br><span class="line">                station.getClass().getClassLoader(), <span class="comment">//类加载器，用来加载代理类</span></span><br><span class="line">                station.getClass().getInterfaces(),<span class="comment">//真实对象实现的接口，代理对象跟真实对象实现同样的接口</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;<span class="comment">//匿名内部类中定义代理对象要处理的业务逻辑</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> method 对应于在代理对象上调用的接口方法的 Method 实例</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> args 代理对象调用接口方法时传递的实际参数</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                        <span class="comment">//执行真实对象</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//声明获取代理对象的工厂</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="comment">//通过工厂获取代理对象</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        <span class="comment">//代理对象执行业务逻辑</span></span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JDK实现动态代理的步骤如下：</p><ol><li>在测试类中通过代理对象调用sell()方法</li><li>根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法</li><li>代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法</li><li>invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法</li></ol></blockquote><h4 id="3-3-3-2-CGLIB动态代理"><a href="#3-3-3-2-CGLIB动态代理" class="headerlink" title="3.3.3.2 CGLIB动态代理"></a>3.3.3.2 CGLIB动态代理</h4><p>如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，<strong>因为JDK动态代理要求必须定义接口</strong>，对接口进行代理。<br>CGLIB是一个功能强大，高性能的代码生成包。<strong>它为没有实现接口的类提供代理，</strong>为JDK的动态代理提供了很好的补充。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 火车站类，没有实现任何接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CGLIB代理工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">obj</span> <span class="operator">=</span> (TrainStation) enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;</span>);</span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">result</span> <span class="operator">=</span> (TrainStation) methodProxy.invokeSuper(o, objects);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.lxg.pattern.proxy.cglib_proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建代理工厂对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line"></span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>三种代理的对比：</strong></p><blockquote><p>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。</p></blockquote><blockquote><p>在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。</p></blockquote><blockquote><p><strong>所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。</strong></p></blockquote><p><strong>两种代理方式的对比：</strong></p><blockquote><p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</p></blockquote><blockquote><p>如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题</p></blockquote><p><strong>优点：</strong></p><blockquote><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li></ul></blockquote><h3 id="3-2-4-外观模式-📌"><a href="#3-2-4-外观模式-📌" class="headerlink" title="3.2.4 外观模式 📌"></a>3.2.4 外观模式 📌</h3><p>功能都给你包装起来了，你不需要知道她是怎么实现的，你只需要知道她可以做你想做的事。</p><img src="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.png" class="" title="外观模式"><p><strong>结构</strong></p><blockquote><p><strong>外观（Facade）角色：</strong>为多个子系统对外提供一个共同的接口。<br><strong>子系统（Sub System）角色：</strong>实现系统的部分功能，客户可以通过外观角色访问它。</p></blockquote><p><strong>例子：</strong></p><blockquote><p>小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：</p></blockquote><img src="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F-%E4%BE%8B%E5%AD%90.png" class="" title="外观模式-例子"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//灯类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了灯....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了灯....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电视类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了电视....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了电视....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirCondition</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了空调....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了空调....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//智能音箱</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartAppliancesFacade</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line">    <span class="keyword">private</span> AirCondition airCondition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmartAppliancesFacade</span><span class="params">()</span> &#123;</span><br><span class="line">        light = <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">        tv = <span class="keyword">new</span> <span class="title class_">TV</span>();</span><br><span class="line">        airCondition = <span class="keyword">new</span> <span class="title class_">AirCondition</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(message.contains(<span class="string">&quot;打开&quot;</span>)) &#123;</span><br><span class="line">            on();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(message.contains(<span class="string">&quot;关闭&quot;</span>)) &#123;</span><br><span class="line">            off();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我还听不懂你说的！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//起床后一键开电器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;起床了&quot;</span>);</span><br><span class="line">        light.on();</span><br><span class="line">        tv.on();</span><br><span class="line">        airCondition.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//睡觉一键关电器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉了&quot;</span>);</span><br><span class="line">        light.off();</span><br><span class="line">        tv.off();</span><br><span class="line">        airCondition.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建外观对象</span></span><br><span class="line">        <span class="type">SmartAppliancesFacade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmartAppliancesFacade</span>();</span><br><span class="line">        <span class="comment">//客户端直接与外观对象进行交互</span></span><br><span class="line">        facade.say(<span class="string">&quot;打开家电&quot;</span>);</span><br><span class="line">        facade.say(<span class="string">&quot;关闭家电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><blockquote><p><strong>优点：</strong></p><ul><li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。<br><strong>缺点：</strong></li><li>不符合开闭原则，修改很麻烦</li></ul></blockquote><p><strong>使用场景：</strong></p><blockquote><ul><li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li><li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li><li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li></ul></blockquote><h3 id="3-2-5-桥接模式-📌"><a href="#3-2-5-桥接模式-📌" class="headerlink" title="3.2.5 桥接模式 📌"></a>3.2.5 桥接模式 📌</h3><p>现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系：</p><img src="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-%E4%BE%8B%E5%AD%90.png" class="" title="桥接模式-例子"><blockquote><p>我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。</p><p>试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。</p><p>他的定义是：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p></blockquote><p><strong>角色：</strong></p><blockquote><ul><li><strong>抽象化（Abstraction）角色 ：</strong>定义抽象类，并包含一个对实现化对象的引用。</li><li><strong>扩展抽象化（Refined Abstraction）角色：</strong>是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li><li><strong>实现化（Implementor）角色 ：</strong>定义实现化角色的接口，供扩展抽象化角色调用。</li><li><strong>具体实现化（Concrete Implementor）角色 ：</strong>给出实现化角色接口的具体实现。</li></ul></blockquote><p><strong>例子：</strong></p><blockquote><p>需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。类图如下</p></blockquote><img src="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-%E4%BE%8B%E5%AD%902.png" class="" title="桥接模式-例子2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//视频文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//avi文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AVIFile</span> <span class="keyword">implements</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;avi视频文件：&quot;</span>+ fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rmvb文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">REVBBFile</span> <span class="keyword">implements</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rmvb文件：&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作系统版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OperatingSystemVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> VideoFile videoFile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OperatingSystemVersion</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.videoFile = videoFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Windows版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Windows</span> <span class="keyword">extends</span> <span class="title class_">OperatingSystem</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Windows</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mac版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mac</span> <span class="keyword">extends</span> <span class="title class_">OperatingSystemVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mac</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OperatingSystem</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Windows</span>(<span class="keyword">new</span> <span class="title class_">AVIFile</span>());</span><br><span class="line">        os.play(<span class="string">&quot;战狼3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</span></span><br><span class="line"><span class="comment">如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。实现细节对客户透明</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用场景</span></span><br><span class="line"><span class="comment">        · 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</span></span><br><span class="line"><span class="comment">        · 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</span></span><br><span class="line"><span class="comment">        · 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="3-2-6-组合模式-📌"><a href="#3-2-6-组合模式-📌" class="headerlink" title="3.2.6 组合模式 📌"></a>3.2.6 组合模式 📌</h3><p>又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><p><strong>结构：</strong></p><blockquote><ul><li><strong>抽象根节点（Component）：</strong>定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</li><li><strong>树枝节点（Composite）：</strong>定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</li><li><strong>叶子节点（Leaf）：</strong>叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li></ul></blockquote><p><strong>使用场景：</strong></p><blockquote><p>组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。</p></blockquote><p><strong>优点：</strong></p><blockquote><ul><li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li><li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</li><li>在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</li><li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//菜单组件  不管是菜单还是菜单项，都应该继承该类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加菜单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MenuComponent menuComponent)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除菜单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MenuComponent menuComponent)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定的子菜单</span></span><br><span class="line">    <span class="keyword">public</span> MenuComponent <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取菜单名称</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuComponent&gt; menuComponentList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Menu</span><span class="params">(String name,<span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        menuComponentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MenuComponent&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        menuComponentList.add(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        menuComponentList.remove(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MenuComponent <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> menuComponentList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">for</span> (MenuComponent menuComponent : menuComponentList) &#123;</span><br><span class="line">            menuComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MenuItem</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MenuItem</span><span class="params">(String name,<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>组合模式的分类</strong><br>在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。</p><blockquote><p><strong>透明组合模式</strong></p><ul><li>透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 MenuComponent 声明了 add、remove 、getChild 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。</li><li>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）</li></ul><p><strong>安全组合模式</strong></p><ul><li>在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 Menu 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。</li></ul></blockquote><h3 id="3-2-7-享元模式-📌"><a href="#3-2-7-享元模式-📌" class="headerlink" title="3.2.7 享元模式 📌"></a>3.2.7 享元模式 📌</h3><p>运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。通过共享的方式高效的支持大量细粒度的对象。</p><p>主要解决了在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p><p><strong>结构：</strong></p><blockquote><ul><li>内部状态，即不会随着环境的改变而改变的可共享部分</li><li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</li></ul></blockquote><p><strong>角色：</strong></p><blockquote><ul><li><strong>抽象享元角色（Flyweight）：</strong>通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li><li><strong>具体享元（Concrete Flyweight）角色 ：</strong>它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li><li><strong>非享元（Unsharable Flyweight)角色 ：</strong>并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</li><li><strong>享元工厂（Flyweight Factory）角色 ：</strong>负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li></ul></blockquote><p><strong>例子：</strong><br>下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。</p><img src="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-%E4%BE%8B%E5%AD%90.png" class="" title="享元模式-例子"><img src="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-%E4%BE%8B%E5%AD%90%E7%B1%BB%E5%9B%BE.png" class="" title="享元模式-例子类图"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getShape</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方块形状：&quot;</span> + <span class="built_in">this</span>.getShape() + <span class="string">&quot; 颜色：&quot;</span> + color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;L&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;O&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, AbstractBox&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BoxFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, AbstractBox&gt;();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">iBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IBox</span>();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">lBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LBox</span>();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">oBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OBox</span>();</span><br><span class="line">        map.put(<span class="string">&quot;I&quot;</span>, iBox);</span><br><span class="line">        map.put(<span class="string">&quot;L&quot;</span>, lBox);</span><br><span class="line">        map.put(<span class="string">&quot;O&quot;</span>, oBox);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BoxFactory <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BoxFactory</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BoxFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AbstractBox <span class="title function_">getBox</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>优缺点</strong></p><blockquote><p><strong>优点：</strong></p><ul><li>极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能</li><li>享元模式中的外部状态相对独立，且不影响内部状态<br><strong>缺点：</strong></li><li>为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂</li></ul></blockquote><p><strong>使用场景：</strong></p><blockquote><ul><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li><li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li></ul></blockquote><h2 id="3-3-行为型模式"><a href="#3-3-行为型模式" class="headerlink" title="3.3 行为型模式"></a><em>3.3 行为型模式</em></h2><hr><h3 id="3-2-1-策略模式-📌"><a href="#3-2-1-策略模式-📌" class="headerlink" title="3.2.1 策略模式 📌"></a>3.2.1 策略模式 📌</h3><h3 id="3-2-2-模板方法模式-📌"><a href="#3-2-2-模板方法模式-📌" class="headerlink" title="3.2.2 模板方法模式 📌"></a>3.2.2 模板方法模式 📌</h3><h3 id="3-2-3-观察者模式-📌"><a href="#3-2-3-观察者模式-📌" class="headerlink" title="3.2.3 观察者模式 📌"></a>3.2.3 观察者模式 📌</h3><h3 id="3-2-4-迭代子模式-📌"><a href="#3-2-4-迭代子模式-📌" class="headerlink" title="3.2.4 迭代子模式 📌"></a>3.2.4 迭代子模式 📌</h3><h3 id="3-2-5-责任链模式-📌"><a href="#3-2-5-责任链模式-📌" class="headerlink" title="3.2.5 责任链模式 📌"></a>3.2.5 责任链模式 📌</h3><h3 id="3-2-6-命令模式-📌"><a href="#3-2-6-命令模式-📌" class="headerlink" title="3.2.6 命令模式 📌"></a>3.2.6 命令模式 📌</h3><h3 id="3-2-7-备忘录模式-📌"><a href="#3-2-7-备忘录模式-📌" class="headerlink" title="3.2.7 备忘录模式 📌"></a>3.2.7 备忘录模式 📌</h3><h3 id="3-2-8-状态模式-📌"><a href="#3-2-8-状态模式-📌" class="headerlink" title="3.2.8 状态模式 📌"></a>3.2.8 状态模式 📌</h3><h3 id="3-2-9-访问者模式-📌"><a href="#3-2-9-访问者模式-📌" class="headerlink" title="3.2.9 访问者模式 📌"></a>3.2.9 访问者模式 📌</h3><h3 id="3-2-10-中介者模式-📌"><a href="#3-2-10-中介者模式-📌" class="headerlink" title="3.2.10 中介者模式 📌"></a>3.2.10 中介者模式 📌</h3><h3 id="3-2-11-解释器模式-📌"><a href="#3-2-11-解释器模式-📌" class="headerlink" title="3.2.11 解释器模式 📌"></a>3.2.11 解释器模式 📌</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 解决方案 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL优化</title>
      <link href="/2024/04/01/SQL%E4%BC%98%E5%8C%96/"/>
      <url>/2024/04/01/SQL%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>学习笔记参考：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://lxg-gofor.github.io/2022/04/13/mysql/mysql8-sql%E4%BC%98%E5%8C%96/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> SQL优化 </tag>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>健身</title>
      <link href="/2023/07/17/%E5%81%A5%E8%BA%AB/"/>
      <url>/2023/07/17/%E5%81%A5%E8%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="笔记自用，侵删"><a href="#笔记自用，侵删" class="headerlink" title="笔记自用，侵删"></a>笔记自用，侵删</h1><h1 id="出自B站up主：好人松松"><a href="#出自B站up主：好人松松" class="headerlink" title="出自B站up主：好人松松"></a>出自B站up主：好人松松</h1><p>此处附上视频链接：<a href="https://www.bilibili.com/video/BV1Hk4y187jF">https://www.bilibili.com/video/BV1Hk4y187jF</a></p><h2 id="配重的顺序"><a href="#配重的顺序" class="headerlink" title="配重的顺序:"></a>配重的顺序:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/0.jpg" class="" title="配重的顺序"><h2 id="训练时长"><a href="#训练时长" class="headerlink" title="训练时长:"></a>训练时长:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/1.jpg" class="" title="训练时长"><h2 id="不同目的-不同配重"><a href="#不同目的-不同配重" class="headerlink" title="不同目的 不同配重:"></a>不同目的 不同配重:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/2.jpg" class="" title="不同目的 不同配重"><h2 id="三分化训练计划"><a href="#三分化训练计划" class="headerlink" title="三分化训练计划:"></a>三分化训练计划:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/3.jpg" class="" title="三分化训练计划"><h2 id="四分化训练计划"><a href="#四分化训练计划" class="headerlink" title="四分化训练计划:"></a>四分化训练计划:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/4.jpg" class="" title="四分化训练计划"><h2 id="具体动作从属于动作模式"><a href="#具体动作从属于动作模式" class="headerlink" title="具体动作从属于动作模式:"></a>具体动作从属于动作模式:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/5.jpg" class="" title="具体动作从属于动作模式"><h2 id="胸肌"><a href="#胸肌" class="headerlink" title="胸肌:"></a>胸肌:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/x1.jpg" class="" title="胸肌1"><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/x2.jpg" class="" title="胸肌2"><h2 id="背部肌群"><a href="#背部肌群" class="headerlink" title="背部肌群:"></a>背部肌群:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/b2.jpg" class="" title="背的动作模式"><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/bs.jpg" class="" title="上背"><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/bx.jpg" class="" title="下背"><h2 id="腹肌"><a href="#腹肌" class="headerlink" title="腹肌:"></a>腹肌:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/f.jpg" class="" title="腹肌"><h2 id="肱二头肌"><a href="#肱二头肌" class="headerlink" title="肱二头肌:"></a>肱二头肌:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/gonger1.jpg" class="" title="肱二头肌1"><h2 id="肱三头肌"><a href="#肱三头肌" class="headerlink" title="肱三头肌:"></a>肱三头肌:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/gongsan1.jpg" class="" title="肱三头肌1"><h2 id="三角肌前束"><a href="#三角肌前束" class="headerlink" title="三角肌前束:"></a>三角肌前束:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/jq1.jpg" class="" title="三角肌前束1"><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/jq2.jpg" class="" title="三角肌前束2"><h2 id="三角肌中束"><a href="#三角肌中束" class="headerlink" title="三角肌中束:"></a>三角肌中束:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/jz2.jpg" class="" title="三角肌中束1"><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/jz3.jpg" class="" title="三角肌中束2"><h2 id="三角肌后束"><a href="#三角肌后束" class="headerlink" title="三角肌后束:"></a>三角肌后束:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/jh1.jpg" class="" title="三角肌后束1"><h2 id="股四头肌"><a href="#股四头肌" class="headerlink" title="股四头肌:"></a>股四头肌:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/gusi1.jpg" class="" title="股四头肌1"><h2 id="股二头肌"><a href="#股二头肌" class="headerlink" title="股二头肌:"></a>股二头肌:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/guer1.jpg" class="" title="股二头肌1"><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/guer2.jpg" class="" title="股二头肌2"><h2 id="臀大肌"><a href="#臀大肌" class="headerlink" title="臀大肌:"></a>臀大肌:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/t1.jpg" class="" title="臀大肌1"><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/t2.jpg" class="" title="臀大肌2"><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/%E6%80%BB%E7%BB%93.jpg" class="" title="总结">]]></content>
      
      
      
        <tags>
            
            <tag> 运动 </tag>
            
            <tag> 健康 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDD领域驱动设计</title>
      <link href="/2023/07/14/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/07/14/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="DDD领域驱动设计"><a href="#DDD领域驱动设计" class="headerlink" title="DDD领域驱动设计"></a>DDD领域驱动设计</h1><h2 id="什么是领域驱动设计"><a href="#什么是领域驱动设计" class="headerlink" title="什么是领域驱动设计"></a>什么是领域驱动设计</h2><p>又被称作基于领域的工程设计。</p><p><strong>那么什么是领域？</strong></p><p>我们暂且可以将其理解为<strong>业务问题的范畴</strong>。比如说打扮自己这项业务就可以分为购买衣服、化妆和健身三个领域，而购买衣服这一领域就包括了挑衣服，试衣服和付款。</p><p>总的来说领域驱动设计其实就是将业务上要做的一件<strong>大事</strong>,通过推演和抽象<strong>拆分成多个内聚的领域。</strong></p><h2 id="DDD名词概念"><a href="#DDD名词概念" class="headerlink" title="DDD名词概念"></a>DDD名词概念</h2><h3 id="什么是DP"><a href="#什么是DP" class="headerlink" title="什么是DP"></a>什么是DP</h3><p>Domain Primitive，在DDD中DP可以说是一切模型、方法、架构的基础，他是在特定领域、拥有精确定义、可以自我验证、拥有行为的对象，可以认为是领域的最小组成部分。</p><p>DP的三条原则：</p><ul><li>让隐性的概念显性化：比如手机号码是具有区号的，如果用String来记录手机号码的话就记录不了区号，如果自行创建一个DP对象，里面包括了手机号码和区号等属性，就能做到将隐性概念显性化的。</li><li>让隐性的上下文显性化：隐性的概念都显性化之后，隐性的上下文自然也显性化了。</li><li>封装多对象行为：一个DP可以封装多个DP。</li></ul><h3 id="什么是Entity"><a href="#什么是Entity" class="headerlink" title="什么是Entity"></a>什么是Entity</h3><p>和DP相比，他俩都是<strong>充血</strong>的，但是Entity是有状态的，DP是组成实体的基础类型，Entity则是有状态的领域实体。</p><p>举个例子： 买门票，如果门票有指定位置，那么这个位置就是有状态的Entity，程序需要通过他的唯一id追踪他的状态，预定状态和行列数等等，如果没有指定位置，进到里面随便坐，那么就是无状态的DP，程序只需要知道座位的总数。</p><h3 id="什么是ACL防腐层"><a href="#什么是ACL防腐层" class="headerlink" title="什么是ACL防腐层"></a>什么是ACL防腐层</h3><p>将两个不同的领域界定开，使得两者结构不受对方的影响，可以通过接口的形式，对外提供<br>访问接口，这样即使业务逻辑产生变化，也不会影响别的系统，如果要进行转义，也可以在防腐层内完成。</p><h3 id="有的没的都概览"><a href="#有的没的都概览" class="headerlink" title="有的没的都概览"></a>有的没的都概览</h3><ul><li>DP: 抽象并封装自检和一些隐性属性的计算逻辑，且这些属性是无状态的。</li><li>Entity: 抽象并封装单对象有状态的逻辑。</li><li>Domain Service: 抽象并封装<strong>多对象</strong>的有状态逻辑。</li><li>Repository: 抽象并封装外部数据访问逻辑。</li></ul><h2 id="DDD思想下的编码过程"><a href="#DDD思想下的编码过程" class="headerlink" title="DDD思想下的编码过程"></a>DDD思想下的编码过程</h2><ol><li>首先对需要处理的业务问题进行总览。</li><li>然后领域对象(Entity) 进行划分，明确每个领域对象的包含的信息和职责边界并进行跨对象，多对象的逻辑组织 (Domain Service)。</li><li>接着在上层应用中根据业务描述去编排Entity和Domain Service。</li><li>最后再做一些下水道（脏，耦合高）工作，去对下层的数据访问，RPC调用去做一些具体实现。</li></ol><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>聚合是对存在引用关系的一组对象的封装，他的目的就是屏蔽掉内部对象之间复杂的关联关系只对外暴露统一接口。<br>例子：在写论文时的各种步骤聚合在一起就是一个与写论文相关的聚合。</p><img src="/2023/07/14/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/1.png" class="" title="聚合概念"><h3 id="聚合根"><a href="#聚合根" class="headerlink" title="聚合根"></a>聚合根</h3><p>聚合根是整个聚合当中唯一能够被外部引用的对象，也就是说聚合所暴露的接口只允许操作根对象。</p><h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><p>判断哪些对象可以被划入聚合的条件</p><h3 id="注销微信账号的例子："><a href="#注销微信账号的例子：" class="headerlink" title="注销微信账号的例子："></a>注销微信账号的例子：</h3><p>注销的时候需要检查钱包里的余额，同时还要检查绑定的银行卡，但是聊天消息微信没有保存，所以就不用管了</p><img src="/2023/07/14/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/3.png" class="" title="注销微信账号的例子"><img src="/2023/07/14/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/2.png" class="" title="聚合接口写法"><p>这里手机号就是微信账号的聚合根</p>]]></content>
      
      
      
        <tags>
            
            <tag> DDD </tag>
            
            <tag> 领域驱动设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习笔记</title>
      <link href="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="初识Docker"><a href="#初识Docker" class="headerlink" title="初识Docker"></a>初识Docker</h1><p>在我们平常部署项目的时候常常会面临组件多，运行环境复杂的问题，而这会导致：</p><ul><li>依赖关系复杂，出现兼容性问题</li><li>开发、测试、生产环境不一样的问题</li></ul><p>装过环境的小伙伴应该都知道这是一个多么烦人的过程，装上了还好说，装不上那就真的是白费心机，浪费时间。</p><p>这时，Docker给出了一个很好的解决方案：</p><p>1、解决大型项目依赖关系复杂，不同组件依赖的兼容性问题</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互隔离</li></ul><p>2、解决开发、测试、生产环境有差异的问题</p><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" class="" title="Docker概念"><h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" class="" title="Docker架构"><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 stable test 和 nightly 三个更新频道。</p><p>官方网站上有各种环境下的 安装指南，这里主要介绍 Docker CE 在 CentOS上的安装。</p><h3 id="CentOS安装Docker"><a href="#CentOS安装Docker" class="headerlink" title="CentOS安装Docker"></a>CentOS安装Docker</h3><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p><h3 id="卸载（可选）"><a href="#卸载（可选）" class="headerlink" title="卸载（可选）"></a>卸载（可选）</h3><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-selinux \</span><br><span class="line">    docker-engine-selinux \</span><br><span class="line">    docker-engine \</span><br><span class="line">    docker-ce</span><br></pre></td></tr></table></figure><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>首先需要大家虚拟机联网，安装yum工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">   device-mapper-persistent-data \</span><br><span class="line">   lvm2 --skip-broken</span><br></pre></td></tr></table></figure><p>更新XFS文件系统管理工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update xfsprogs -y</span><br></pre></td></tr></table></figure><p>然后更新本地镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置docker镜像源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决域名问题</span></span><br><span class="line">sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27;/etc/yum.repos.d/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新镜像源缓存</span></span><br><span class="line">yum makecache fast</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后输入命令</span></span><br><span class="line">yum install -y docker-ce</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一定要关闭防火墙后，再启动docker</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁止开机启动防火墙</span></span><br><span class="line">systemctl disablefirewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过命令启动docker：</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后输入命令，可以查看docker版本</span></span><br><span class="line">docker --version</span><br></pre></td></tr></table></figure><h3 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h3><p>docker官方镜像仓库网速较差，我们需要设置国内镜像：<br>参考阿里云的镜像加速文档：<br><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>总结</p><ul><li>什么是Docker：<br>  帮助我们快速构建应用镜像、交付应用、运行应用的技术</li><li>什么是镜像：<br>  将应用程序及其依赖、环境、配置打包在一起就是镜像</li><li>什么是容器：<br>  镜像运行起来就是容器，一个镜像可以运行多个容器</li><li>Docker工作流：<br>  构建自定义镜像或者从DockerRegistry拉取镜像<br>  根据镜像创建容器，并运行</li></ul><p>补充：<br>    Docker容器化虚拟化与传统虚拟机比较</p><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" class="" title="Docker容器化虚拟化与传统虚拟机比较"><h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><h2 id="Docker进程相关命令"><a href="#Docker进程相关命令" class="headerlink" title="Docker进程相关命令"></a>Docker进程相关命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动docker服务</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止docker服务</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启docker服务</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看docker服务状态</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置开机启动docker服务</span></span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><h2 id="Docker镜像相关命令"><a href="#Docker镜像相关命令" class="headerlink" title="Docker镜像相关命令"></a>Docker镜像相关命令</h2><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png" class="" title="Docker镜像相关命令"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看本地所有的镜像</span></span><br><span class="line">docker images</span><br><span class="line">docker images –q # 查看所镜像的id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从网络中查找需要的镜像</span></span><br><span class="line">docker search 镜像名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。 如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。</span></span><br><span class="line">docker pull 镜像名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除本地镜像</span></span><br><span class="line">docker rmi 镜像id # 删除指定本地镜像</span><br><span class="line">docker rmi `docker images -q` # 删除所有本地镜像</span><br></pre></td></tr></table></figure><h2 id="Docker容器相关命令"><a href="#Docker容器相关命令" class="headerlink" title="Docker容器相关命令"></a>Docker容器相关命令</h2><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.png" class="" title="Docker容器相关命令"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器</span></span><br><span class="line">docker ps # 查看正在运行的容器</span><br><span class="line">docker ps –a # 查看所有容器</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建并启动容器</span></span><br><span class="line">docker run 参数</span><br><span class="line"></span><br><span class="line">参数说明:</span><br><span class="line">• -i: 保持容器运行。通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。</span><br><span class="line">• -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用。</span><br><span class="line">• -d: 以守护(后台)模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭。</span><br><span class="line">• -it: 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器</span><br><span class="line">• --name: 为创建的容器命名。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以后台方式运行容器，并进入容器</span></span><br><span class="line">[root@hecs-33111 ~]# docker run-id --name=c2 redis:5.0 /bin/bash</span><br><span class="line">3842cee27f9b97fa7fb512aa53f835351f8860ffd5a4dc0e19b9e36d7aadf54</span><br><span class="line">[root@hecs-33111 ~]# docker exec-it c2 /bin/bash</span><br><span class="line">root@3842cee27f9b:/data# </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器</span></span><br><span class="line">docker exec 参数 # 退出容器，容器不会关闭</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器</span></span><br><span class="line">docker stop 容器名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动容器</span></span><br><span class="line">docker start 容器名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除容器</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果容器是运行状态则删除失败，需要停止容器才能删除</span></span><br><span class="line">docker rm 容器名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器信息</span></span><br><span class="line">docker inspect 容器名称</span><br></pre></td></tr></table></figure><h1 id="Docker容器的数据卷"><a href="#Docker容器的数据卷" class="headerlink" title="Docker容器的数据卷"></a>Docker容器的数据卷</h1><p>Docker容器中产生的数据本身也是保存在容器中的，所以删除容器的话容器中的数据也会一并被删除。还有些时候Docker容器之间或者和外部机器之间需要进行数据交互。</p><p>如果想要解决这两个问题就需要用到数据卷。</p><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.png" class="" title="Docker容器的数据卷"><h2 id="配置数据卷"><a href="#配置数据卷" class="headerlink" title="配置数据卷"></a>配置数据卷</h2><p>在创建容器时，使用-v参数设置数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ... –v 宿主机目录(文件):容器内目录(文件) ...</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>目录必须是绝对路径</li><li>如果目录不存在会自动创建</li><li>可以挂在多个数据卷，即容器A和容器B可以使用同一个数据卷</li></ul><p><strong>多个容器挂载一个数据卷</strong></p><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先创建启动容器c3并挂载数据卷</span></span><br><span class="line">docker run –it --name=c3 –v /volume centos:7 /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建启动 c1 c2 容器，使用 –-volumes-from 参数 设置数据卷</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用参数--volumes-from来达到与c3容器使用同一个数据卷的效果</span></span><br><span class="line">docker run –it --name=c1 --volumes-from c3 centos:7 /bin/bash </span><br><span class="line">docker run –it --name=c2 --volumes-from c3 centos:7 /bin/bash</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>数据卷概念</li></ol><ul><li>宿主机的一个目录或文件</li></ul><ol start="2"><li>数据卷作用</li></ol><ul><li>容器数据持久化</li><li>客户端和容器数据交换</li><li>容器间数据交换</li></ul><ol start="3"><li>数据卷容器</li></ol><ul><li>创建一个容器，挂载一个目录，让其他容器继承自该容器(–volume-from)。</li><li>通过简单方式实现数据卷配置</li></ul><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="Docker镜像原理"><a href="#Docker镜像原理" class="headerlink" title="Docker镜像原理"></a>Docker镜像原理</h2><p>经过以上几章的介绍，相信你已经对Docker有了更进一步的了解，如果还没有自己拉取过几个镜像并部署容器的话赶紧先去试试吧，如果已经尝试过了，那么你可能会发现：</p><ul><li>Docker中CentOS的镜像大小只有200m，但是操作系统的ISO却有几个G</li><li>一个Tomcat的安装包只有70m，但是Docker中拉取的镜像却有500m</li></ul><p>这就要涉及到Docker镜像的原理了，下面我们将展开对Docker镜像原理的介绍。</p><p>首先我们要了解一个操作系统的组成部分：</p><ul><li>进程调度子程序</li><li>进程通信子程序</li><li>内存管理子程序</li><li>设备管理子程序</li><li><strong>文件管理子程序</strong></li><li>网络通信子程序</li><li>作业控制子程序</li></ul><p>其中文件管理子系统</p><ol><li>rootfs: root文件系统，包含的就是典型 Linux 系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准目录和文件</li><li>bootfs: 加载引导程序(bootloader)+内核 (kernel)</li><li>不同的linux发行版本，bootfs基本一样，rootfs不同</li></ol><ul><li>Docker镜像是由特殊的文件系统叠加而成的</li><li>最低端是bootfs并使用宿主机的bootfs</li><li>第二层是root文件系统rootfs,称为base image</li><li>然后再往上可以参加其他系统的镜像文件</li><li>统一文件系统(Union File Svstem)技术能够将不同的层整合成一个文件系统，为这些层提供一个统一的视角，这样就隐藏了多层的存在，在用户的角度来看，只存在一个文件系统。</li><li>一个镜像可以放在另一个镜像的上面，位于下面的镜像称为父镜像，最底层的镜像称为基础镜像当从一个镜像启动容器的时候，Docker会在最顶层加载一个读写文件系统作为容器</li></ul><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.png" class="" title="Docker镜像原理"><h2 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a>镜像制作</h2><p>有两种方法：<br><strong>一、容器转为镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commit 容器id 镜像名称:版本号</span><br><span class="line">save -o 压缩文件名称 镜像名称:版本号</span><br><span class="line">load - 压缩文件名称</span><br></pre></td></tr></table></figure><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.png" class="" title="Docker镜像原理2"><p><strong>二、dockerfile</strong></p><ul><li>Dockerfile 是一个文本文件</li><li>包含了一条条的指令</li><li>每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像</li><li>对于开发人员：可以为开发团队提供一个完全一致的开发环境</li><li>对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了对于运维人员：在部署时，可以实现应用的无缝移植</li></ul><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.png" class="" title="dockerfile关键字1"><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.png" class="" title="dockerfile关键字2"><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>自定义一个 centos7镜像</p><ol><li>默认登录路径为&#x2F;usr</li><li>可以使用vim<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 步骤</span></span></span><br><span class="line">1. 定义一个父镜像 FROM centos:7</span><br><span class="line">2. 定义作者信息 MAINTAINER Shelton &lt;uli65535@gmail.com&gt;</span><br><span class="line">3. 执行安装vim的命令 RUN yum install -y vim</span><br><span class="line">4. 定义默认的工作目录WORKDIR /usr</span><br><span class="line">5. 定义容器的启动执行命令CMD /bin/bash</span><br></pre></td></tr></table></figure></li></ol><h1 id="Docker服务编排"><a href="#Docker服务编排" class="headerlink" title="Docker服务编排"></a>Docker服务编排</h1><p>微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，维护的工作量会很大</p><ul><li>要从Dockerfilebuildimage或者去dockerhub拉取image</li><li>要创建多个container</li><li>要管理这些container (启动停止删除)</li></ul><p>服务编排: 按照一定的业务规则批量管理容器</p><p>Docker Compose就是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建启动和停止。使用步骤:</p><ol><li>利用 Dockerfile定义运行环境镜像</li><li>使用docker-composeyml定义组成应用的各服务</li><li>运行 docker-composeup启动应用</li></ol><p><strong>安装Docker-Compose</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Compose目前已经完全支持Linux、Mac OS和Windows，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在我们安装Compose之前，需要先安装Docker</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面我们以编译好的二进制包方式安装在Linux系统中。</span> </span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置文件可执行权限</span> </span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看版本信息</span> </span><br><span class="line">docker-compose -version</span><br></pre></td></tr></table></figure><p><strong>卸载Docker Compose</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">二进制包方式安装的，删除二进制文件即可</span></span><br><span class="line">rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="案例：同时启动nginx和SpringBoot项目（已经创建为docker中的容器，名为app）"><a href="#案例：同时启动nginx和SpringBoot项目（已经创建为docker中的容器，名为app）" class="headerlink" title="案例：同时启动nginx和SpringBoot项目（已经创建为docker中的容器，名为app）"></a>案例：同时启动nginx和SpringBoot项目（已经创建为docker中的容器，名为app）</h3><p>1、创建docker-compose目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/docker-compose</span><br><span class="line">cd ~/docker-compose</span><br></pre></td></tr></table></figure><p>2、编写 docker-compose.yml 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">   image: nginx</span><br><span class="line">   ports:</span><br><span class="line">    - 80:80</span><br><span class="line">   links:</span><br><span class="line">    - app</span><br><span class="line">   volumes:</span><br><span class="line">    - ./nginx/conf.d:/etc/nginx/conf.d</span><br><span class="line">  app:</span><br><span class="line">    image: app</span><br><span class="line">    expose:</span><br><span class="line">      - &quot;8080&quot;</span><br></pre></td></tr></table></figure><p>3、创建.&#x2F;nginx&#x2F;conf.d目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ./nginx/conf.d</span><br></pre></td></tr></table></figure><p>4、在.&#x2F;nginx&#x2F;conf.d目录下 编写shelton.conf文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    access_log off;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://app:8080;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、在~&#x2F;docker-compose 目录下 使用docker-compose 启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p>6、测试访问</p><h1 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h1><p>Docker官方的Docker hub (<a href="https://hub.docker.com/">https://hub.docker.com</a>) 是一个用于管理公共镜像的仓库，我们可以从上面拉取镜像到本地，也可以把我们自己的镜像推送上去。但是，有时候我们的服务器无法访问互联网，或者你不希望将自己的镜像放到公网当中，那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像。</p><p>一、私有仓库搭建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1、拉取私有仓库镜像</span> </span><br><span class="line">docker pull registry</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2、启动私有仓库容器</span> </span><br><span class="line">docker run -id --name=registry -p 5000:5000 registry</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3、打开浏览器 输入地址http://私有仓库服务器ip:5000/v2/_catalog，看到&#123;<span class="string">&quot;repositories&quot;</span>:[]&#125; 表示私有仓库 搭建成功</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4、修改daemon.json</span>   </span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器ip修改为自己私有仓库服务器真实ip</span> </span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;私有仓库服务器ip:5000&quot;]&#125; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5、重启docker 服务</span> </span><br><span class="line">systemctl restart docker</span><br><span class="line">docker start registry</span><br></pre></td></tr></table></figure><p>二、将镜像上传至私有仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1、标记镜像为私有仓库的镜像</span>     </span><br><span class="line">docker tag centos:7 私有仓库服务器IP:5000/centos:7</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2、上传标记的镜像</span>     </span><br><span class="line">docker push 私有仓库服务器IP:5000/centos:7</span><br></pre></td></tr></table></figure><p>三、 从私有仓库拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拉取镜像</span> </span><br><span class="line">docker pull 私有仓库服务器ip:5000/centos:7</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB</title>
      <link href="/2023/05/20/MongoDB/"/>
      <url>/2023/05/20/MongoDB/</url>
      
        <content type="html"><![CDATA[<h1 id="1-MongoDB相关概念"><a href="#1-MongoDB相关概念" class="headerlink" title="1. MongoDB相关概念"></a>1. MongoDB相关概念</h1><h2 id="1-1-业务场景"><a href="#1-1-业务场景" class="headerlink" title="1.1 业务场景"></a>1.1 业务场景</h2><p>传统的关系型数据库 (比如 MySQL), 在数据操作的”三高”需求以及对应的 Web 2.0 网站需求面前, 会有”力不从心”的感觉</p><p>所谓的三高是:<br><strong>高并发,</strong><br><strong>高性能,</strong><br><strong>高可用</strong></p><ul><li><p>High Performance: 对数据库的<strong>高并发读写</strong>的要求</p></li><li><p>High Storage: 对<strong>海量数据</strong>的高效率存储和访问的需求</p></li><li><p>High Scalability &amp;&amp; High Available: 对数据的<strong>高扩展性和高可用性</strong>的需求</p></li></ul><p><strong>而 MongoDB 可以应对三高需求</strong></p><p>具体的应用场景:</p><ol><li>社交场景, 使用 MongoDB 存储存储用户信息, 以及用户发表的朋友圈信息, 通过地理位置索引实现附近的人, 地点等功能。</li><li>游戏场景, 使用 MongoDB 存储游戏用户信息, 用户的装备, 积分等直接以内嵌文档的形式存储, 方便查询, 高效率存储和访问。</li><li>物流场景, 使用 MongoDB 存储订单信息, 订单状态在运送过程中会不断更新, 以 MongoDB 内嵌数组的形式来存储, 一次查询就能将订单所有的变更读取出来。</li><li>物联网场景, 使用 MongoDB 存储所有接入的智能设备信息, 以及设备汇报的日志信息, 并对这些信息进行多维度的分析。</li><li>视频直播, 使用 MongoDB 存储用户信息, 点赞互动信息等。</li></ol><p>这些应用场景中, 数据操作方面的共同点有:</p><ul><li>数据量大</li><li>写入操作频繁</li><li>价值较低的数据, 对事务性要求不高</li></ul><p>对于这样的数据, 更适合用 MongoDB 来实现数据存储</p><p>那么我们什么时候选择 MongoDB 呢?</p><p>除了架构选型上, 除了上述三个特点之外, 还要考虑下面这些问题:</p><ul><li>应用不需要事务及复杂 JOIN 支持</li><li>新应用, 需求会变, 数据模型无法确定, 想快速迭代开发</li><li>应用需要 2000 - 3000 以上的读写QPS（更高也可以）</li><li>应用需要 TB 甚至 PB 级别数据存储</li><li>应用发展迅速, 需要能快速水平扩展</li><li>应用要求存储的数据不丢失</li><li>应用需要 99.999% 高可用</li><li>应用需要大量的地理位置查询, 文本查询</li></ul><p>如果上述有1个符合, 可以考虑 MongoDB, 2个及以上的符合, 选择MongoDB绝不会后悔。</p><h2 id="1-2-MongoDB-简介"><a href="#1-2-MongoDB-简介" class="headerlink" title="1.2 MongoDB 简介"></a>1.2 MongoDB 简介</h2><p>MongoDB是一个开源, 高性能, 无模式的文档型数据库, 当初的设计就是用于简化开发和方便扩展, 是NoSQL数据库产品中的一种。<strong>是最像关系型数据库（MySQL）的非关系型数据库</strong>。</p><p>它支持的数据结构非常松散, 是一种<strong>类似于JSON的格式叫BSON</strong>, 所以它既可以存储比较复杂的数据类型, 又相当的灵活。</p><p>MongoDB中的记录是一个文档, 它是一个由字段和值对（ﬁeld:value）组成的数据结构。MongoDB文档类似于JSON对象, 即一个文档认为就是一个对象.字段的数据类型是字符型, 它的值除了使用基本的一些类型外, 还可以包括其他文档, 普通数组和文档数组。</p><img src="/2023/05/20/MongoDB/1.png" class="" title="MySQL与MongoDB相比"><img src="/2023/05/20/MongoDB/2.png" class="" title="MySQL与MongoDB相比2"><p>Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><p>MongoDB中的记录是一个文档, 是一个键值对。字段的数据类型是字符型, 值除了使用基本的一些类型以外, 还包括其它文档, 普通数组以及文档数组。</p><p>MongoDB数据类型参考列表如下：</p><img src="/2023/05/20/MongoDB/2.png" class="" title="MySQL与MongoDB相比2"><p>MongoDB数据模型是面向文档的, 所谓文档就是一种类似于JSON的结构, 简单理解MongoDB这个数据库中存在的是各种各样的JSON（BSON）</p><p>在 MongoDB 中, 数据库和集合都不需要手动创建, 当我们创建文档时, 如果文档所在的集合或者数据库不存在, 则会自动创建数据库或者集合</p><h2 id="1-3-MongoDB-特点"><a href="#1-3-MongoDB-特点" class="headerlink" title="1.3 MongoDB 特点"></a>1.3 MongoDB 特点</h2><h3 id="1-3-1-高性能"><a href="#1-3-1-高性能" class="headerlink" title="1.3.1 高性能"></a>1.3.1 高性能</h3><p>MongoDB 提供高性能的数据持久化</p><ul><li>嵌入式数据模型的支持减少了数据库系统上的 I&#x2F;O 活动</li><li>索引支持更快的查询, 并且可以包含来自嵌入式文档和数组的键 (文本索引解决搜索的需求, TTL 索引解决历史数据自动过期的需求, 地理位置索引可以用于构件各种 O2O 应用)</li><li>mmapv1, wiredtiger, mongorocks (rocksdb) in-memory 等多引擎支持满足各种场景需求</li><li>Gridfs 解决文件存储需求</li></ul><h3 id="1-3-2-高可用"><a href="#1-3-2-高可用" class="headerlink" title="1.3.2 高可用"></a>1.3.2 高可用</h3><p>MongoDB 的复制工具称作副本集 (replica set) 可以提供自动故障转移和数据冗余</p><h3 id="1-3-3-高扩展"><a href="#1-3-3-高扩展" class="headerlink" title="1.3.3 高扩展"></a>1.3.3 高扩展</h3><p>水平扩展是其核心功能一部分</p><p>分片将数据分布在一组集群的机器上 (海量数据存储, 服务能力水平扩展)</p><p>MongoDB 支持基于片键创建数据区域, 在一个平衡的集群当中, MongoDB 将一个区域所覆盖的读写只定向到该区域的那些片</p><h3 id="1-3-4-丰富的查询支持"><a href="#1-3-4-丰富的查询支持" class="headerlink" title="1.3.4 丰富的查询支持"></a>1.3.4 丰富的查询支持</h3><p>MongoDB支持丰富的查询语言, 支持读和写操作(CRUD), 比如数据聚合, 文本搜索和地理空间查询等。</p><h3 id="1-3-5-其他特点"><a href="#1-3-5-其他特点" class="headerlink" title="1.3.5 其他特点"></a>1.3.5 其他特点</h3><p>无模式（动态模式）, 灵活的文档模型。</p><h1 id="2-常用基本命令"><a href="#2-常用基本命令" class="headerlink" title="2. 常用基本命令"></a>2. 常用基本命令</h1><h2 id="2-1-数据库操作"><a href="#2-1-数据库操作" class="headerlink" title="2.1 数据库操作"></a>2.1 数据库操作</h2><h3 id="2-1-1-选择和创建数据库"><a href="#2-1-1-选择和创建数据库" class="headerlink" title="2.1.1 选择和创建数据库"></a>2.1.1 选择和创建数据库</h3><p>选择和创建数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果数据库不存在则自动创建</span></span><br><span class="line">use 数据库名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果创建了但是不往里面存东西他是不会保存这个库的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">相当于use 一个不存在的库，会在内存中创建这个库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">但是不往里面放任何集合的话就不会持久化到磁盘</span></span><br></pre></td></tr></table></figure><p>查看有权限查看的所有的数据库命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show dbs </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">show databases</span><br></pre></td></tr></table></figure><p>查看当前正在使用的数据库命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db</span><br><span class="line"><span class="comment">#MongoDB 中默认的数据库为 test，如果你没有选择数据库，集合将存放在 test 数据库中。</span></span><br></pre></td></tr></table></figure><p>另外：</p><p>数据库名可以是满足以下条件的任意UTF-8字符串。</p><ul><li>不能是空字符串（””)。</li><li>不得含有’ ‘（空格)、.、$、&#x2F;、\和\0 (空字符)。</li><li>应全部小写。</li><li>最多64字节。</li></ul><p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p><ul><li>admin：从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特<br>定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li><li>local：这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li><li>config：当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li></ul><h3 id="2-1-2-数据库的删除"><a href="#2-1-2-数据库的删除" class="headerlink" title="2.1.2 数据库的删除"></a>2.1.2 数据库的删除</h3><p>删除已经持久化的数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure><h2 id="2-2集合操作"><a href="#2-2集合操作" class="headerlink" title="2.2集合操作"></a>2.2集合操作</h2><p>集合，类似关系型数据库中的表。</p><p>可以显示的创建，也可以隐式的创建。</p><h3 id="2-2-1-集合的显式创建"><a href="#2-2-1-集合的显式创建" class="headerlink" title="2.2.1 集合的显式创建"></a>2.2.1 集合的显式创建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">name：要创建的集合的名称</span></span><br><span class="line">db.createCollection(name)</span><br></pre></td></tr></table></figure><p>查看当前库中的表：show tables命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show collections </span><br><span class="line">或</span><br><span class="line">show tables</span><br></pre></td></tr></table></figure><p>集合的命名规范：</p><ul><li>集合名不能是空字符串””。</li><li>集合名不能含有\0字符（空字符），这个字符表示集合名的结尾。</li><li>集合名不能以”system.”开头，这是为系统集合保留的前缀。</li><li>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。</li></ul><h3 id="2-2-2-集合的隐式创建"><a href="#2-2-2-集合的隐式创建" class="headerlink" title="2.2.2 集合的隐式创建"></a>2.2.2 集合的隐式创建</h3><p>当向一个集合中插入一个文档的时候，如果集合不存在，则会自动创建集合。</p><h3 id="2-2-3-集合的删除"><a href="#2-2-3-集合的删除" class="headerlink" title="2.2.3 集合的删除"></a>2.2.3 集合的删除</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.collection.drop() </span><br><span class="line">或</span><br><span class="line">db.集合.drop()</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果成功删除选定集合，则 drop() 方法返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span></span><br></pre></td></tr></table></figure><h2 id="2-3-文档基本CRUD"><a href="#2-3-文档基本CRUD" class="headerlink" title="2.3 文档基本CRUD"></a>2.3 文档基本CRUD</h2><p>文档（document）的数据结构和 JSON 基本一样。</p><p>所有存储在集合中的数据都是 BSON 格式。</p><h3 id="2-3-1-文档的插入"><a href="#2-3-1-文档的插入" class="headerlink" title="2.3.1 文档的插入"></a>2.3.1 文档的插入</h3><p>①单个文档插入<br>使用insert()或者save()向集合中插入文档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection.insert( </span><br><span class="line">    &lt;document or array of documents&gt;, </span><br><span class="line">    &#123; </span><br><span class="line">        writeConcern: &lt;document&gt;, </span><br><span class="line">        ordered: &lt;boolean&gt; </span><br><span class="line">    &#125; </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数说明：</p><img src="/2023/05/20/MongoDB/4.png" class="" title="文档插入指令的参数说明"><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.comment.insert(</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;articleid&quot;: &quot;100000&quot;,</span><br><span class="line">        &quot;content&quot;: &quot;今天天气真好,阳光明媚&quot;,</span><br><span class="line">        &quot;userid&quot;: &quot;1001&quot;,</span><br><span class="line">        &quot;nickname&quot;: &quot;Rose&quot;,</span><br><span class="line">        &quot;createdatetime&quot;: new Date(),</span><br><span class="line">        &quot;likenum&quot;: NumberInt(10),</span><br><span class="line">        &quot;state&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>提示：</p><ol><li>comment集合如果不存在，则会隐式创建。</li><li>mongo中的数字，默认情况下是double类型，如果要存整型，必须使用函数NumberInt(整型数字)，否则取出来就有问题了。</li><li>插入当前日期使用 new Date()</li><li>插入的数据没有指定 _id，会自动生成主键值</li><li>如果某字段没值，可以赋值为null，或不写该字段。</li></ol><p>执行后，如下，说明插入一个数据成功了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WriteResult(&#123; &quot;nInserted&quot;: 1 &#125;)</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>文档中的键&#x2F;值对是有序的。</li><li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档）。</li><li>MongoDB区分类型和大小写。</li><li>MongoDB的文档不能有重复的键。</li><li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</li></ol><p>文档键命名规范：</p><ul><li>键不能含有\0 (空字符)。这个字符用来表示键的结尾。</li><li>.和$有特别的意义，只有在特定环境下才能使用。</li><li>以下划线”_”开头的键是保留的(不是严格要求的)。</li></ul><p>②批量插入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.collection.insertMany( [ </span><br><span class="line">        &lt;document 1&gt;, </span><br><span class="line">        &lt;document 2&gt;,</span><br><span class="line">        ... </span><br><span class="line">    ], </span><br><span class="line">    &#123; </span><br><span class="line">        writeConcern: &lt;document&gt;, </span><br><span class="line">        ordered: &lt;boolean&gt; </span><br><span class="line">    &#125; </span><br><span class="line">)</span><br></pre></td></tr></table></figure><img src="/2023/05/20/MongoDB/5.png" class="" title="批量插入指令的参数说明"><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">db.comment.insertMany([ </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">            &quot;articleid&quot;: &quot;100001&quot;,</span><br><span class="line">            &quot;content&quot;: &quot;我们不应该把清晨浪费在手机上，健康很重要，一杯温水幸福你我他。&quot;,</span><br><span class="line">            &quot;userid&quot;: &quot;1002&quot;,</span><br><span class="line">            &quot;nickname&quot;: &quot;相忘于江湖&quot;,</span><br><span class="line">            &quot;createdatetime&quot;: new Date(&quot;2019-08-05T22:08:15.522Z&quot;),</span><br><span class="line">            &quot;likenum&quot;:NumberInt(1000),</span><br><span class="line">            &quot;state&quot;:&quot;1&quot;</span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_id&quot;:&quot;2&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我夏天空腹喝凉开水，冬天喝温开水&quot;,&quot;userid&quot;:&quot;1005&quot;,&quot;nickname&quot;:&quot;伊人憔 悴&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-05T23:58:51.485Z&quot;),&quot;likenum&quot;:NumberInt(888),&quot;state&quot;:&quot;1&quot;</span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_id&quot;:&quot;3&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我一直喝凉开水，冬天夏天都喝。&quot;,&quot;userid&quot;:&quot;1004&quot;,&quot;nickname&quot;:&quot;杰克船 长&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-06T01:05:06.321Z&quot;),&quot;likenum&quot;:NumberInt(666),&quot;state&quot;:&quot;1&quot;</span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_id&quot;:&quot;4&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;专家说不能空腹吃饭，影响健康。&quot;,&quot;userid&quot;:&quot;1003&quot;,&quot;nickname&quot;:&quot;凯 撒&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-06T08:18:35.288Z&quot;),&quot;likenum&quot;:NumberInt(2000),&quot;state&quot;:&quot;1&quot;</span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_id&quot;:&quot;5&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;研究表明，刚烧开的水千万不能喝，因为烫 嘴。&quot;,&quot;userid&quot;:&quot;1003&quot;,&quot;nickname&quot;:&quot;凯撒&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08- 06T11:01:02.521Z&quot;),&quot;likenum&quot;:NumberInt(3000),&quot;state&quot;:&quot;1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>提示：</p><p>插入时指定了_id ，则主键就是该值。</p><p>如果某条数据插入失败，将会终止插入，但已经插入成功的数据不会回滚掉。</p><p>因为批量插入由于数据较多容易出现失败，因此，可以使用try catch进行异常捕捉处理，测试的时候可以不处理。<br>如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">try &#123; </span><br><span class="line">    db.comment.insertMany([ </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_id&quot;:&quot;1&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我们不应该把清晨浪费在手机上，健康很重要，一杯温水幸福你我 他。&quot;,&quot;userid&quot;:&quot;1002&quot;,&quot;nickname&quot;:&quot;相忘于江湖&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08- 05T22:08:15.522Z&quot;),</span><br><span class="line">            &quot;likenum&quot;:NumberInt(1000),</span><br><span class="line">            &quot;state&quot;:&quot;1&quot;</span><br><span class="line">        &#125;, </span><br><span class="line">            &#123;&quot;_id&quot;:&quot;2&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我夏天空腹喝凉开水，冬天喝温开水&quot;,&quot;userid&quot;:&quot;1005&quot;,&quot;nickname&quot;:&quot;伊人憔 悴&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-05T23:58:51.485Z&quot;),</span><br><span class="line">            &quot;likenum&quot;:NumberInt(888),</span><br><span class="line">            &quot;state&quot;:&quot;1&quot;&#125;, </span><br><span class="line">            &#123;&quot;_id&quot;:&quot;3&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我一直喝凉开水，冬天夏天都喝。&quot;,&quot;userid&quot;:&quot;1004&quot;,&quot;nickname&quot;:&quot;杰克船 长&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-06T01:05:06.321Z&quot;),</span><br><span class="line">            &quot;likenum&quot;:NumberInt(666),</span><br><span class="line">            &quot;state&quot;:&quot;1&quot;&#125;, </span><br><span class="line">            &#123;&quot;_id&quot;:&quot;4&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;专家说不能空腹吃饭，影响健康。&quot;,&quot;userid&quot;:&quot;1003&quot;,&quot;nickname&quot;:&quot;凯 撒&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-06T08:18:35.288Z&quot;),</span><br><span class="line">            &quot;likenum&quot;:NumberInt(2000),</span><br><span class="line">            &quot;state&quot;:&quot;1&quot;&#125;, </span><br><span class="line">            &#123;&quot;_id&quot;:&quot;5&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;研究表明，刚烧开的水千万不能喝，因为烫 嘴。&quot;,&quot;userid&quot;:&quot;1003&quot;,&quot;nickname&quot;:&quot;凯撒&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08- 06T11:01:02.521Z&quot;),</span><br><span class="line">            &quot;likenum&quot;:NumberInt(3000),</span><br><span class="line">            &quot;state&quot;:&quot;1&quot;</span><br><span class="line">        &#125; </span><br><span class="line">    ]); </span><br><span class="line">&#125; catch (e) &#123; </span><br><span class="line">    print (e); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-文档的基本查询"><a href="#2-3-2-文档的基本查询" class="headerlink" title="2.3.2 文档的基本查询"></a>2.3.2 文档的基本查询</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(&lt;query&gt;, [projection])</span><br></pre></td></tr></table></figure><img src="/2023/05/20/MongoDB/6.png" class="" title="文档的基本查询指令的参数说明"><p>例子：</p><p>①查询所有</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果我们要查询spit集合的所有文档，我们输入以下命令</span></span><br><span class="line">db.comment.find() </span><br><span class="line">或</span><br><span class="line">db.comment.find(&#123;&#125;)</span><br></pre></td></tr></table></figure><p>这里你会发现每条文档会有一个叫_id的字段，这个相当于我们原来关系数据库中表的主键，当你在插入文档记录时没有指定该字段，MongoDB会自动创建，其类型是ObjectID类型。</p><p>如果我们在插入文档记录时指定该字段也可以，其类型可以是ObjectID类型，也可以是MongoDB支持的任意类型。</p><p>如果我想按一定条件来查询，比如我想查询userid为1003的记录，怎么办？很简单！只要在find()中添加参数即可，参数也是json格式，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;userid:&#x27;1003&#x27;&#125;)</span><br></pre></td></tr></table></figure><p>如果你只需要返回符合条件的第一条数据，我们可以使用findOne命令来实现，语法和find一样。<br>如：查询用户编号是1003的记录，但只最多返回符合条件的第一条记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.findOne(&#123;userid:&#x27;1003&#x27;&#125;)</span><br></pre></td></tr></table></figure><p>②投影查询（Projection Query）：</p><p>如果要查询结果返回部分字段，则需要使用投影查询（不显示所有字段，只显示指定的字段）。</p><p>如：查询结果只显示 _id、userid、nickname：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:1,nickname:1&#125;) </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">出现如下结果</span></span><br><span class="line">&#123; &quot;_id&quot; : &quot;4&quot;, &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125; </span><br><span class="line">&#123; &quot;_id&quot; : &quot;5&quot;, &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125;</span><br></pre></td></tr></table></figure><p>可以发现默认 _id 会自动显示。</p><p>如果不想让他出现可以这样操作：<br>如：查询结果只显示 、userid、nickname ，不显示 _id ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:1,nickname:1,_id:0&#125;) </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">出现如下结果</span></span><br><span class="line">&#123; &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125; </span><br><span class="line">&#123; &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-文档的更新"><a href="#2-3-3-文档的更新" class="headerlink" title="2.3.3 文档的更新"></a>2.3.3 文档的更新</h3><p>更新文档的语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(query, update, options) </span><br><span class="line">//或 </span><br><span class="line">db.collection.update( </span><br><span class="line">    &lt;query&gt;, </span><br><span class="line">    &lt;update&gt;, </span><br><span class="line">    &#123; </span><br><span class="line">        upsert: &lt;boolean&gt;, </span><br><span class="line">        multi: &lt;boolean&gt;, </span><br><span class="line">        writeConcern: &lt;document&gt;, </span><br><span class="line">        collation: &lt;document&gt;, </span><br><span class="line">        arrayFilters: [ </span><br><span class="line">            &lt;filterdocument1&gt;, </span><br><span class="line">            ... </span><br><span class="line">        ], </span><br><span class="line">        hint: &lt;document|string&gt; // Available starting in MongoDB 4.2 </span><br><span class="line">    &#125; </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数：</p><img src="/2023/05/20/MongoDB/7.png" class="" title="文档的更新指令的参数说明"><h3 id="2-3-4-文档的删除"><a href="#2-3-4-文档的删除" class="headerlink" title="2.3.4 文档的删除"></a>2.3.4 文档的删除</h3><p>①db.<collection_name>.deleteMany()<br>删除所有匹配的文档.</p><p>②db.<collection_name>.deleteOne()<br>删除单个匹配的文档</p><p>例1：删除 userId&#x3D;456 的所有文档</p><img src="/2023/05/20/MongoDB/8.png" class="" title="文档的删除演示"><h1 id="3-索引"><a href="#3-索引" class="headerlink" title="3 索引"></a>3 索引</h1><p>MongoDB中的索引使得其查询效率变得更高了，MongoDB的索引原理和MySQL的一样。</p><h2 id="3-1-索引的分类"><a href="#3-1-索引的分类" class="headerlink" title="3.1 索引的分类"></a>3.1 索引的分类</h2><p>1、单字段索引<br>MongoDB 支持在文档的单个字段上创建用户定义的升序&#x2F;降序索引, 称为单字段索引</p><p>2、复合索引<br>MongoDB 支持多个字段的用户定义索引, 即复合索引 </p><p>3、地理空间索引<br>为了支持对地理空间坐标数据的有效查询, MongoDB 提供了两种特殊的索引: 返回结果时使用平面几何的二维索引和返回结果时使用球面几何的二维球面索引</p><p>4、哈希索引<br>为了支持基于散列的分片, MongoDB 提供了散列索引类型, 它对字段值的散列进行索引.这些索引在其范围内的值分布更加随机, 但只支持相等匹配, 不支持基于范围的查询.</p><p>5、文本索引<br>MongoDB 提供了一种文本索引类型, 支持在集合中搜索字符串内容，这些文本索引不存储特定于语言的停止词（例如 “the”, “a”, “or”）, 而将集合中的词作为词干, 只存储根词。</p><h2 id="3-2-索引的相关命令"><a href="#3-2-索引的相关命令" class="headerlink" title="3.2 索引的相关命令"></a>3.2 索引的相关命令</h2><p>①db.<collection_name>.getIndexes() 查看索引</p><img src="/2023/05/20/MongoDB/9.png" class="" title="查看索引"><p>②db.<collection_name>.createIndex() 创建索引</p><img src="/2023/05/20/MongoDB/10.png" class="" title="创建索引"><p>③db.Test.dropIndex() 删除索引</p><p>db.Test.dropIndexes() 删除所有索引【默认的_id索引不会被删除】</p><img src="/2023/05/20/MongoDB/11.png" class="" title="删除索引"><p>④explain() 查看执行计划</p><img src="/2023/05/20/MongoDB/12.png" class="" title="查看执行计划"><h1 id="4-副本集"><a href="#4-副本集" class="headerlink" title="4 副本集"></a>4 副本集</h1><p>MongoDB 通过使用副本集来实现复制，副本集只能有一个主节点。</p><ul><li>副本集是一组两个或更多节点（通常最少需要 3 个节点）；</li><li>在副本集中，一个节点是主要节点，其余节点是从节点；</li><li>所有数据从主节点复制到从节点；</li><li>在自动故障转移或维护时，将为主节点建立选举，并选举一个新的主节点；</li><li>恢复失败的节点后，它再次加入副本集并用作辅助节点。</li><li>副本集中，主节点 和 从节点 中数据是一样的，从节点和主节点保持一致</li></ul><img src="/2023/05/20/MongoDB/13.png" class="" title="副本集"><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">副本集是指同一份数据被保存到N个机器上，每个机器上都是想同的数据。</span><br><span class="line"></span><br><span class="line">分片是指一份数据被分离开保存到N个机器上，N个机器上的数据组合起来是一份数据。</span><br></pre></td></tr></table></figure><h1 id="5-分片"><a href="#5-分片" class="headerlink" title="5 分片"></a>5 分片</h1><h2 id="5-1-分片是什么？"><a href="#5-1-分片是什么？" class="headerlink" title="5.1 分片是什么？"></a>5.1 分片是什么？</h2><p>分片是<strong>跨多台机器存储数据</strong>的过程，它是 MongoDB 满足数据增长需求的方法。随着数据的不断增加，单台机器可能不足以存储全部数据，也无法提供足够的读写吞吐量。通过分片，可以添加更多计算机来满足数据增长和读&#x2F;写操作的需求。<strong>分片中，不同机器内存储的数据是不一样的</strong></p><h2 id="5-2-有副本集不就够了，为什么要分片？"><a href="#5-2-有副本集不就够了，为什么要分片？" class="headerlink" title="5.2 有副本集不就够了，为什么要分片？"></a>5.2 有副本集不就够了，为什么要分片？</h2><ul><li>在复制中，所有写操作都将转到主节点；</li><li>对延迟敏感的查询仍会转到主查询；</li><li>单个副本集限制为 12 个节点；</li><li>当活动数据集很大时，会出现内存不足；</li><li>本地磁盘不够大；</li><li>垂直扩展价格昂贵。</li></ul><h2 id="5-3-分片结构"><a href="#5-3-分片结构" class="headerlink" title="5.3 分片结构"></a>5.3 分片结构</h2><img src="/2023/05/20/MongoDB/14.png" class="" title="分片结构"><ul><li>Shards（碎片）：用于<strong>存储实际的数据块</strong>，在生产环境中，每个分片都是一个单独的副本集，它们提供了高可用性和数据一致性；</li><li>Config Servers（配置服务器）：用于存储集群的元数据，此数据包含集群数据集到碎片的映射。查询路由器使用此元数据将操作定向到特定的碎片。在生产环境中，分片群集恰好具有 3 个配置服务器；</li><li>Query Routers（查询路由器）：查询路由器基本上都是 mongo 实例，可与客户端应用程序接口并将操作定向到适当的分片。<strong>查询路由器处理操作并将其定位到分片，然后将结果返回给客户端</strong>。分片群集可以包含多个查询路由器来划分客户端请求负载。客户端将请求发送到一个查询路由器。通常，<strong>分片群集具有许多查询路由器</strong>。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> 非关系型数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
