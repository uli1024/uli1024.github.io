<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/06/11/SQL%E4%BC%98%E5%8C%96/"/>
      <url>/2024/06/11/SQL%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h1><p>当Java开发快一年了，设计模式这门必修居然忘得差不多了，有点离谱，有点惭愧，有点遗憾。</p><p>今下决心，将其重新拾起，故作此笔记以记录学习过程，便于日后再再拾起（手动狗头</p><h1 id="1-设计模式全图概览"><a href="#1-设计模式全图概览" class="headerlink" title="1. 设计模式全图概览"></a>1. 设计模式全图概览</h1><h1 id="1-1-学习视频地址"><a href="#1-1-学习视频地址" class="headerlink" title="1.1 学习视频地址"></a>1.1 学习视频地址</h1><p>作为BiliBili大学黑马老师教出来的程序员，自然还是首选黑马：<br><a href="https://www.bilibili.com/video/BV1Np4y1z7BU">https://www.bilibili.com/video/BV1Np4y1z7BU</a></p><h1 id="1-2-为什么需要学"><a href="#1-2-为什么需要学" class="headerlink" title="1.2 为什么需要学"></a>1.2 为什么需要学</h1><ul><li>提高程序员的思维能力（即让我们的思维更加开阔，如果后期我们要去设计咱们的软件的话，那么就能套用这些设计模式去设计咱们的软件了）、编程能力和设计能力。当然，在这里我们更强调的是设计能力</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强</li></ul><h1 id="1-3-设计模式的分类"><a href="#1-3-设计模式的分类" class="headerlink" title="1.3 设计模式的分类"></a>1.3 设计模式的分类</h1><p>23种设计模式分为三大类型：</p><ul><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul><h1 id="1-3-1-创建型模式"><a href="#1-3-1-创建型模式" class="headerlink" title="1.3.1 创建型模式"></a>1.3.1 创建型模式</h1><p>创建型模式包含了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">工厂模式</span><br><span class="line">抽象工厂模式</span><br><span class="line">单例模式</span><br><span class="line">建造者模式</span><br><span class="line">原型模式</span><br></pre></td></tr></table></figure><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。<strong>简单地说就是用于描述”怎样创建对象”，它的主要特点是”将对象的创建与使用分离”，将创建和使用解耦。</strong></p><h1 id="1-3-2-结构型模式"><a href="#1-3-2-结构型模式" class="headerlink" title="1.3.2 结构型模式"></a>1.3.2 结构型模式</h1><p>结构型模式包含了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">适配器模式</span><br><span class="line">装饰器模式</span><br><span class="line">代理模式</span><br><span class="line">外观模式</span><br><span class="line">桥接模式</span><br><span class="line">组合模式</span><br><span class="line">享元模式</span><br></pre></td></tr></table></figure><h1 id="1-3-3-行为型模式"><a href="#1-3-3-行为型模式" class="headerlink" title="1.3.3 行为型模式"></a>1.3.3 行为型模式</h1><p>行为型模式包含了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">策略模式</span><br><span class="line">模板方法模式</span><br><span class="line">观察者模式</span><br><span class="line">迭代子模式</span><br><span class="line">责任链模式</span><br><span class="line">命令模式</span><br><span class="line">备忘录模式</span><br><span class="line">状态模式</span><br><span class="line">访问者模式</span><br><span class="line">中介者模式</span><br><span class="line">解释器模式</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>健身</title>
      <link href="/2023/07/17/%E5%81%A5%E8%BA%AB/"/>
      <url>/2023/07/17/%E5%81%A5%E8%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="笔记自用，侵删"><a href="#笔记自用，侵删" class="headerlink" title="笔记自用，侵删"></a>笔记自用，侵删</h1><h1 id="出自B站up主：好人松松"><a href="#出自B站up主：好人松松" class="headerlink" title="出自B站up主：好人松松"></a>出自B站up主：好人松松</h1><p>此处附上视频链接：<a href="https://www.bilibili.com/video/BV1Hk4y187jF">https://www.bilibili.com/video/BV1Hk4y187jF</a></p><h2 id="配重的顺序"><a href="#配重的顺序" class="headerlink" title="配重的顺序:"></a>配重的顺序:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/0.jpg" class="" title="配重的顺序"><h2 id="训练时长"><a href="#训练时长" class="headerlink" title="训练时长:"></a>训练时长:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/1.jpg" class="" title="训练时长"><h2 id="不同目的-不同配重"><a href="#不同目的-不同配重" class="headerlink" title="不同目的 不同配重:"></a>不同目的 不同配重:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/2.jpg" class="" title="不同目的 不同配重"><h2 id="三分化训练计划"><a href="#三分化训练计划" class="headerlink" title="三分化训练计划:"></a>三分化训练计划:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/3.jpg" class="" title="三分化训练计划"><h2 id="四分化训练计划"><a href="#四分化训练计划" class="headerlink" title="四分化训练计划:"></a>四分化训练计划:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/4.jpg" class="" title="四分化训练计划"><h2 id="具体动作从属于动作模式"><a href="#具体动作从属于动作模式" class="headerlink" title="具体动作从属于动作模式:"></a>具体动作从属于动作模式:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/5.jpg" class="" title="具体动作从属于动作模式"><h2 id="胸肌"><a href="#胸肌" class="headerlink" title="胸肌:"></a>胸肌:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/x1.jpg" class="" title="胸肌1"><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/x2.jpg" class="" title="胸肌2"><h2 id="背部肌群"><a href="#背部肌群" class="headerlink" title="背部肌群:"></a>背部肌群:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/b2.jpg" class="" title="背的动作模式"><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/bs.jpg" class="" title="上背"><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/bx.jpg" class="" title="下背"><h2 id="腹肌"><a href="#腹肌" class="headerlink" title="腹肌:"></a>腹肌:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/f.jpg" class="" title="腹肌"><h2 id="肱二头肌"><a href="#肱二头肌" class="headerlink" title="肱二头肌:"></a>肱二头肌:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/gonger1.jpg" class="" title="肱二头肌1"><h2 id="肱三头肌"><a href="#肱三头肌" class="headerlink" title="肱三头肌:"></a>肱三头肌:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/gongsan1.jpg" class="" title="肱三头肌1"><h2 id="三角肌前束"><a href="#三角肌前束" class="headerlink" title="三角肌前束:"></a>三角肌前束:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/jq1.jpg" class="" title="三角肌前束1"><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/jq2.jpg" class="" title="三角肌前束2"><h2 id="三角肌中束"><a href="#三角肌中束" class="headerlink" title="三角肌中束:"></a>三角肌中束:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/jz2.jpg" class="" title="三角肌中束1"><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/jz3.jpg" class="" title="三角肌中束2"><h2 id="三角肌后束"><a href="#三角肌后束" class="headerlink" title="三角肌后束:"></a>三角肌后束:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/jh1.jpg" class="" title="三角肌后束1"><h2 id="股四头肌"><a href="#股四头肌" class="headerlink" title="股四头肌:"></a>股四头肌:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/gusi1.jpg" class="" title="股四头肌1"><h2 id="股二头肌"><a href="#股二头肌" class="headerlink" title="股二头肌:"></a>股二头肌:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/guer1.jpg" class="" title="股二头肌1"><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/guer2.jpg" class="" title="股二头肌2"><h2 id="臀大肌"><a href="#臀大肌" class="headerlink" title="臀大肌:"></a>臀大肌:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/t1.jpg" class="" title="臀大肌1"><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/t2.jpg" class="" title="臀大肌2"><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><img src="/2023/07/17/%E5%81%A5%E8%BA%AB/%E6%80%BB%E7%BB%93.jpg" class="" title="总结">]]></content>
      
      
      
        <tags>
            
            <tag> 运动 </tag>
            
            <tag> 健康 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDD领域驱动设计</title>
      <link href="/2023/07/14/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/07/14/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="DDD领域驱动设计"><a href="#DDD领域驱动设计" class="headerlink" title="DDD领域驱动设计"></a>DDD领域驱动设计</h1><h2 id="什么是领域驱动设计"><a href="#什么是领域驱动设计" class="headerlink" title="什么是领域驱动设计"></a>什么是领域驱动设计</h2><p>又被称作基于领域的工程设计。</p><p><strong>那么什么是领域？</strong></p><p>我们暂且可以将其理解为<strong>业务问题的范畴</strong>。比如说打扮自己这项业务就可以分为购买衣服、化妆和健身三个领域，而购买衣服这一领域就包括了挑衣服，试衣服和付款。</p><p>总的来说领域驱动设计其实就是将业务上要做的一件<strong>大事</strong>,通过推演和抽象<strong>拆分成多个内聚的领域。</strong></p><h2 id="DDD名词概念"><a href="#DDD名词概念" class="headerlink" title="DDD名词概念"></a>DDD名词概念</h2><h3 id="什么是DP"><a href="#什么是DP" class="headerlink" title="什么是DP"></a>什么是DP</h3><p>Domain Primitive，在DDD中DP可以说是一切模型、方法、架构的基础，他是在特定领域、拥有精确定义、可以自我验证、拥有行为的对象，可以认为是领域的最小组成部分。</p><p>DP的三条原则：</p><ul><li>让隐性的概念显性化：比如手机号码是具有区号的，如果用String来记录手机号码的话就记录不了区号，如果自行创建一个DP对象，里面包括了手机号码和区号等属性，就能做到将隐性概念显性化的。</li><li>让隐性的上下文显性化：隐性的概念都显性化之后，隐性的上下文自然也显性化了。</li><li>封装多对象行为：一个DP可以封装多个DP。</li></ul><h3 id="什么是Entity"><a href="#什么是Entity" class="headerlink" title="什么是Entity"></a>什么是Entity</h3><p>和DP相比，他俩都是<strong>充血</strong>的，但是Entity是有状态的，DP是组成实体的基础类型，Entity则是有状态的领域实体。</p><p>举个例子： 买门票，如果门票有指定位置，那么这个位置就是有状态的Entity，程序需要通过他的唯一id追踪他的状态，预定状态和行列数等等，如果没有指定位置，进到里面随便坐，那么就是无状态的DP，程序只需要知道座位的总数。</p><h3 id="什么是ACL防腐层"><a href="#什么是ACL防腐层" class="headerlink" title="什么是ACL防腐层"></a>什么是ACL防腐层</h3><p>将两个不同的领域界定开，使得两者结构不受对方的影响，可以通过接口的形式，对外提供<br>访问接口，这样即使业务逻辑产生变化，也不会影响别的系统，如果要进行转义，也可以在防腐层内完成。</p><h3 id="有的没的都概览"><a href="#有的没的都概览" class="headerlink" title="有的没的都概览"></a>有的没的都概览</h3><ul><li>DP: 抽象并封装自检和一些隐性属性的计算逻辑，且这些属性是无状态的。</li><li>Entity: 抽象并封装单对象有状态的逻辑。</li><li>Domain Service: 抽象并封装<strong>多对象</strong>的有状态逻辑。</li><li>Repository: 抽象并封装外部数据访问逻辑。</li></ul><h2 id="DDD思想下的编码过程"><a href="#DDD思想下的编码过程" class="headerlink" title="DDD思想下的编码过程"></a>DDD思想下的编码过程</h2><ol><li>首先对需要处理的业务问题进行总览。</li><li>然后领域对象(Entity) 进行划分，明确每个领域对象的包含的信息和职责边界并进行跨对象，多对象的逻辑组织 (Domain Service)。</li><li>接着在上层应用中根据业务描述去编排Entity和Domain Service。</li><li>最后再做一些下水道（脏，耦合高）工作，去对下层的数据访问，RPC调用去做一些具体实现。</li></ol><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>聚合是对存在引用关系的一组对象的封装，他的目的就是屏蔽掉内部对象之间复杂的关联关系只对外暴露统一接口。<br>例子：在写论文时的各种步骤聚合在一起就是一个与写论文相关的聚合。</p><img src="/2023/07/14/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/1.png" class="" title="聚合概念"><h3 id="聚合根"><a href="#聚合根" class="headerlink" title="聚合根"></a>聚合根</h3><p>聚合根是整个聚合当中唯一能够被外部引用的对象，也就是说聚合所暴露的接口只允许操作根对象。</p><h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><p>判断哪些对象可以被划入聚合的条件</p><h3 id="注销微信账号的例子："><a href="#注销微信账号的例子：" class="headerlink" title="注销微信账号的例子："></a>注销微信账号的例子：</h3><p>注销的时候需要检查钱包里的余额，同时还要检查绑定的银行卡，但是聊天消息微信没有保存，所以就不用管了</p><img src="/2023/07/14/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/3.png" class="" title="注销微信账号的例子"><img src="/2023/07/14/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/2.png" class="" title="聚合接口写法"><p>这里手机号就是微信账号的聚合根</p>]]></content>
      
      
      
        <tags>
            
            <tag> DDD </tag>
            
            <tag> 领域驱动设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习笔记</title>
      <link href="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="初识Docker"><a href="#初识Docker" class="headerlink" title="初识Docker"></a>初识Docker</h1><p>在我们平常部署项目的时候常常会面临组件多，运行环境复杂的问题，而这会导致：</p><ul><li>依赖关系复杂，出现兼容性问题</li><li>开发、测试、生产环境不一样的问题</li></ul><p>装过环境的小伙伴应该都知道这是一个多么烦人的过程，装上了还好说，装不上那就真的是白费心机，浪费时间。</p><p>这时，Docker给出了一个很好的解决方案：</p><p>1、解决大型项目依赖关系复杂，不同组件依赖的兼容性问题</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互隔离</li></ul><p>2、解决开发、测试、生产环境有差异的问题</p><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" class="" title="Docker概念"><h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" class="" title="Docker架构"><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 stable test 和 nightly 三个更新频道。</p><p>官方网站上有各种环境下的 安装指南，这里主要介绍 Docker CE 在 CentOS上的安装。</p><h3 id="CentOS安装Docker"><a href="#CentOS安装Docker" class="headerlink" title="CentOS安装Docker"></a>CentOS安装Docker</h3><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p><h3 id="卸载（可选）"><a href="#卸载（可选）" class="headerlink" title="卸载（可选）"></a>卸载（可选）</h3><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-selinux \</span><br><span class="line">    docker-engine-selinux \</span><br><span class="line">    docker-engine \</span><br><span class="line">    docker-ce</span><br></pre></td></tr></table></figure><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>首先需要大家虚拟机联网，安装yum工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">   device-mapper-persistent-data \</span><br><span class="line">   lvm2 --skip-broken</span><br></pre></td></tr></table></figure><p>更新XFS文件系统管理工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update xfsprogs -y</span><br></pre></td></tr></table></figure><p>然后更新本地镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置docker镜像源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决域名问题</span></span><br><span class="line">sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27;/etc/yum.repos.d/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新镜像源缓存</span></span><br><span class="line">yum makecache fast</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后输入命令</span></span><br><span class="line">yum install -y docker-ce</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一定要关闭防火墙后，再启动docker</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁止开机启动防火墙</span></span><br><span class="line">systemctl disablefirewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过命令启动docker：</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后输入命令，可以查看docker版本</span></span><br><span class="line">docker --version</span><br></pre></td></tr></table></figure><h3 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h3><p>docker官方镜像仓库网速较差，我们需要设置国内镜像：<br>参考阿里云的镜像加速文档：<br><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>总结</p><ul><li>什么是Docker：<br>  帮助我们快速构建应用镜像、交付应用、运行应用的技术</li><li>什么是镜像：<br>  将应用程序及其依赖、环境、配置打包在一起就是镜像</li><li>什么是容器：<br>  镜像运行起来就是容器，一个镜像可以运行多个容器</li><li>Docker工作流：<br>  构建自定义镜像或者从DockerRegistry拉取镜像<br>  根据镜像创建容器，并运行</li></ul><p>补充：<br>    Docker容器化虚拟化与传统虚拟机比较</p><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" class="" title="Docker容器化虚拟化与传统虚拟机比较"><h1 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h1><h2 id="Docker进程相关命令"><a href="#Docker进程相关命令" class="headerlink" title="Docker进程相关命令"></a>Docker进程相关命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动docker服务</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止docker服务</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启docker服务</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看docker服务状态</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置开机启动docker服务</span></span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><h2 id="Docker镜像相关命令"><a href="#Docker镜像相关命令" class="headerlink" title="Docker镜像相关命令"></a>Docker镜像相关命令</h2><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png" class="" title="Docker镜像相关命令"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看本地所有的镜像</span></span><br><span class="line">docker images</span><br><span class="line">docker images –q # 查看所镜像的id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从网络中查找需要的镜像</span></span><br><span class="line">docker search 镜像名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。 如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。</span></span><br><span class="line">docker pull 镜像名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除本地镜像</span></span><br><span class="line">docker rmi 镜像id # 删除指定本地镜像</span><br><span class="line">docker rmi `docker images -q` # 删除所有本地镜像</span><br></pre></td></tr></table></figure><h2 id="Docker容器相关命令"><a href="#Docker容器相关命令" class="headerlink" title="Docker容器相关命令"></a>Docker容器相关命令</h2><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.png" class="" title="Docker容器相关命令"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器</span></span><br><span class="line">docker ps # 查看正在运行的容器</span><br><span class="line">docker ps –a # 查看所有容器</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建并启动容器</span></span><br><span class="line">docker run 参数</span><br><span class="line"></span><br><span class="line">参数说明:</span><br><span class="line">• -i: 保持容器运行。通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。</span><br><span class="line">• -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用。</span><br><span class="line">• -d: 以守护(后台)模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭。</span><br><span class="line">• -it: 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器</span><br><span class="line">• --name: 为创建的容器命名。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以后台方式运行容器，并进入容器</span></span><br><span class="line">[root@hecs-33111 ~]# docker run-id --name=c2 redis:5.0 /bin/bash</span><br><span class="line">3842cee27f9b97fa7fb512aa53f835351f8860ffd5a4dc0e19b9e36d7aadf54</span><br><span class="line">[root@hecs-33111 ~]# docker exec-it c2 /bin/bash</span><br><span class="line">root@3842cee27f9b:/data# </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器</span></span><br><span class="line">docker exec 参数 # 退出容器，容器不会关闭</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器</span></span><br><span class="line">docker stop 容器名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动容器</span></span><br><span class="line">docker start 容器名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除容器</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果容器是运行状态则删除失败，需要停止容器才能删除</span></span><br><span class="line">docker rm 容器名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器信息</span></span><br><span class="line">docker inspect 容器名称</span><br></pre></td></tr></table></figure><h1 id="Docker容器的数据卷"><a href="#Docker容器的数据卷" class="headerlink" title="Docker容器的数据卷"></a>Docker容器的数据卷</h1><p>Docker容器中产生的数据本身也是保存在容器中的，所以删除容器的话容器中的数据也会一并被删除。还有些时候Docker容器之间或者和外部机器之间需要进行数据交互。</p><p>如果想要解决这两个问题就需要用到数据卷。</p><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.png" class="" title="Docker容器的数据卷"><h2 id="配置数据卷"><a href="#配置数据卷" class="headerlink" title="配置数据卷"></a>配置数据卷</h2><p>在创建容器时，使用-v参数设置数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ... –v 宿主机目录(文件):容器内目录(文件) ...</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>目录必须是绝对路径</li><li>如果目录不存在会自动创建</li><li>可以挂在多个数据卷，即容器A和容器B可以使用同一个数据卷</li></ul><p><strong>多个容器挂载一个数据卷</strong></p><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先创建启动容器c3并挂载数据卷</span></span><br><span class="line">docker run –it --name=c3 –v /volume centos:7 /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建启动 c1 c2 容器，使用 –-volumes-from 参数 设置数据卷</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用参数--volumes-from来达到与c3容器使用同一个数据卷的效果</span></span><br><span class="line">docker run –it --name=c1 --volumes-from c3 centos:7 /bin/bash </span><br><span class="line">docker run –it --name=c2 --volumes-from c3 centos:7 /bin/bash</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>数据卷概念</li></ol><ul><li>宿主机的一个目录或文件</li></ul><ol start="2"><li>数据卷作用</li></ol><ul><li>容器数据持久化</li><li>客户端和容器数据交换</li><li>容器间数据交换</li></ul><ol start="3"><li>数据卷容器</li></ol><ul><li>创建一个容器，挂载一个目录，让其他容器继承自该容器(–volume-from)。</li><li>通过简单方式实现数据卷配置</li></ul><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="Docker镜像原理"><a href="#Docker镜像原理" class="headerlink" title="Docker镜像原理"></a>Docker镜像原理</h2><p>经过以上几章的介绍，相信你已经对Docker有了更进一步的了解，如果还没有自己拉取过几个镜像并部署容器的话赶紧先去试试吧，如果已经尝试过了，那么你可能会发现：</p><ul><li>Docker中CentOS的镜像大小只有200m，但是操作系统的ISO却有几个G</li><li>一个Tomcat的安装包只有70m，但是Docker中拉取的镜像却有500m</li></ul><p>这就要涉及到Docker镜像的原理了，下面我们将展开对Docker镜像原理的介绍。</p><p>首先我们要了解一个操作系统的组成部分：</p><ul><li>进程调度子程序</li><li>进程通信子程序</li><li>内存管理子程序</li><li>设备管理子程序</li><li><strong>文件管理子程序</strong></li><li>网络通信子程序</li><li>作业控制子程序</li></ul><p>其中文件管理子系统</p><ol><li>rootfs: root文件系统，包含的就是典型 Linux 系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准目录和文件</li><li>bootfs: 加载引导程序(bootloader)+内核 (kernel)</li><li>不同的linux发行版本，bootfs基本一样，rootfs不同</li></ol><ul><li>Docker镜像是由特殊的文件系统叠加而成的</li><li>最低端是bootfs并使用宿主机的bootfs</li><li>第二层是root文件系统rootfs,称为base image</li><li>然后再往上可以参加其他系统的镜像文件</li><li>统一文件系统(Union File Svstem)技术能够将不同的层整合成一个文件系统，为这些层提供一个统一的视角，这样就隐藏了多层的存在，在用户的角度来看，只存在一个文件系统。</li><li>一个镜像可以放在另一个镜像的上面，位于下面的镜像称为父镜像，最底层的镜像称为基础镜像当从一个镜像启动容器的时候，Docker会在最顶层加载一个读写文件系统作为容器</li></ul><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.png" class="" title="Docker镜像原理"><h2 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a>镜像制作</h2><p>有两种方法：<br><strong>一、容器转为镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commit 容器id 镜像名称:版本号</span><br><span class="line">save -o 压缩文件名称 镜像名称:版本号</span><br><span class="line">load - 压缩文件名称</span><br></pre></td></tr></table></figure><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.png" class="" title="Docker镜像原理2"><p><strong>二、dockerfile</strong></p><ul><li>Dockerfile 是一个文本文件</li><li>包含了一条条的指令</li><li>每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像</li><li>对于开发人员：可以为开发团队提供一个完全一致的开发环境</li><li>对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了对于运维人员：在部署时，可以实现应用的无缝移植</li></ul><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.png" class="" title="dockerfile关键字1"><img src="/2023/06/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.png" class="" title="dockerfile关键字2"><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>自定义一个 centos7镜像</p><ol><li>默认登录路径为&#x2F;usr</li><li>可以使用vim<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 步骤</span></span></span><br><span class="line">1. 定义一个父镜像 FROM centos:7</span><br><span class="line">2. 定义作者信息 MAINTAINER Shelton &lt;uli65535@gmail.com&gt;</span><br><span class="line">3. 执行安装vim的命令 RUN yum install -y vim</span><br><span class="line">4. 定义默认的工作目录WORKDIR /usr</span><br><span class="line">5. 定义容器的启动执行命令CMD /bin/bash</span><br></pre></td></tr></table></figure></li></ol><h1 id="Docker服务编排"><a href="#Docker服务编排" class="headerlink" title="Docker服务编排"></a>Docker服务编排</h1><p>微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，维护的工作量会很大</p><ul><li>要从Dockerfilebuildimage或者去dockerhub拉取image</li><li>要创建多个container</li><li>要管理这些container (启动停止删除)</li></ul><p>服务编排: 按照一定的业务规则批量管理容器</p><p>Docker Compose就是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建启动和停止。使用步骤:</p><ol><li>利用 Dockerfile定义运行环境镜像</li><li>使用docker-composeyml定义组成应用的各服务</li><li>运行 docker-composeup启动应用</li></ol><p><strong>安装Docker-Compose</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Compose目前已经完全支持Linux、Mac OS和Windows，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在我们安装Compose之前，需要先安装Docker</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面我们以编译好的二进制包方式安装在Linux系统中。</span> </span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置文件可执行权限</span> </span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看版本信息</span> </span><br><span class="line">docker-compose -version</span><br></pre></td></tr></table></figure><p><strong>卸载Docker Compose</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">二进制包方式安装的，删除二进制文件即可</span></span><br><span class="line">rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="案例：同时启动nginx和SpringBoot项目（已经创建为docker中的容器，名为app）"><a href="#案例：同时启动nginx和SpringBoot项目（已经创建为docker中的容器，名为app）" class="headerlink" title="案例：同时启动nginx和SpringBoot项目（已经创建为docker中的容器，名为app）"></a>案例：同时启动nginx和SpringBoot项目（已经创建为docker中的容器，名为app）</h3><p>1、创建docker-compose目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/docker-compose</span><br><span class="line">cd ~/docker-compose</span><br></pre></td></tr></table></figure><p>2、编写 docker-compose.yml 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">   image: nginx</span><br><span class="line">   ports:</span><br><span class="line">    - 80:80</span><br><span class="line">   links:</span><br><span class="line">    - app</span><br><span class="line">   volumes:</span><br><span class="line">    - ./nginx/conf.d:/etc/nginx/conf.d</span><br><span class="line">  app:</span><br><span class="line">    image: app</span><br><span class="line">    expose:</span><br><span class="line">      - &quot;8080&quot;</span><br></pre></td></tr></table></figure><p>3、创建.&#x2F;nginx&#x2F;conf.d目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ./nginx/conf.d</span><br></pre></td></tr></table></figure><p>4、在.&#x2F;nginx&#x2F;conf.d目录下 编写shelton.conf文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    access_log off;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://app:8080;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、在~&#x2F;docker-compose 目录下 使用docker-compose 启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p>6、测试访问</p><h1 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h1><p>Docker官方的Docker hub (<a href="https://hub.docker.com/">https://hub.docker.com</a>) 是一个用于管理公共镜像的仓库，我们可以从上面拉取镜像到本地，也可以把我们自己的镜像推送上去。但是，有时候我们的服务器无法访问互联网，或者你不希望将自己的镜像放到公网当中，那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像。</p><p>一、私有仓库搭建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1、拉取私有仓库镜像</span> </span><br><span class="line">docker pull registry</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2、启动私有仓库容器</span> </span><br><span class="line">docker run -id --name=registry -p 5000:5000 registry</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3、打开浏览器 输入地址http://私有仓库服务器ip:5000/v2/_catalog，看到&#123;<span class="string">&quot;repositories&quot;</span>:[]&#125; 表示私有仓库 搭建成功</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4、修改daemon.json</span>   </span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器ip修改为自己私有仓库服务器真实ip</span> </span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;私有仓库服务器ip:5000&quot;]&#125; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5、重启docker 服务</span> </span><br><span class="line">systemctl restart docker</span><br><span class="line">docker start registry</span><br></pre></td></tr></table></figure><p>二、将镜像上传至私有仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1、标记镜像为私有仓库的镜像</span>     </span><br><span class="line">docker tag centos:7 私有仓库服务器IP:5000/centos:7</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2、上传标记的镜像</span>     </span><br><span class="line">docker push 私有仓库服务器IP:5000/centos:7</span><br></pre></td></tr></table></figure><p>三、 从私有仓库拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拉取镜像</span> </span><br><span class="line">docker pull 私有仓库服务器ip:5000/centos:7</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB</title>
      <link href="/2023/05/20/MongoDB/"/>
      <url>/2023/05/20/MongoDB/</url>
      
        <content type="html"><![CDATA[<h1 id="1-MongoDB相关概念"><a href="#1-MongoDB相关概念" class="headerlink" title="1. MongoDB相关概念"></a>1. MongoDB相关概念</h1><h2 id="1-1-业务场景"><a href="#1-1-业务场景" class="headerlink" title="1.1 业务场景"></a>1.1 业务场景</h2><p>传统的关系型数据库 (比如 MySQL), 在数据操作的”三高”需求以及对应的 Web 2.0 网站需求面前, 会有”力不从心”的感觉</p><p>所谓的三高是:<br><strong>高并发,</strong><br><strong>高性能,</strong><br><strong>高可用</strong></p><ul><li><p>High Performance: 对数据库的<strong>高并发读写</strong>的要求</p></li><li><p>High Storage: 对<strong>海量数据</strong>的高效率存储和访问的需求</p></li><li><p>High Scalability &amp;&amp; High Available: 对数据的<strong>高扩展性和高可用性</strong>的需求</p></li></ul><p><strong>而 MongoDB 可以应对三高需求</strong></p><p>具体的应用场景:</p><ol><li>社交场景, 使用 MongoDB 存储存储用户信息, 以及用户发表的朋友圈信息, 通过地理位置索引实现附近的人, 地点等功能。</li><li>游戏场景, 使用 MongoDB 存储游戏用户信息, 用户的装备, 积分等直接以内嵌文档的形式存储, 方便查询, 高效率存储和访问。</li><li>物流场景, 使用 MongoDB 存储订单信息, 订单状态在运送过程中会不断更新, 以 MongoDB 内嵌数组的形式来存储, 一次查询就能将订单所有的变更读取出来。</li><li>物联网场景, 使用 MongoDB 存储所有接入的智能设备信息, 以及设备汇报的日志信息, 并对这些信息进行多维度的分析。</li><li>视频直播, 使用 MongoDB 存储用户信息, 点赞互动信息等。</li></ol><p>这些应用场景中, 数据操作方面的共同点有:</p><ul><li>数据量大</li><li>写入操作频繁</li><li>价值较低的数据, 对事务性要求不高</li></ul><p>对于这样的数据, 更适合用 MongoDB 来实现数据存储</p><p>那么我们什么时候选择 MongoDB 呢?</p><p>除了架构选型上, 除了上述三个特点之外, 还要考虑下面这些问题:</p><ul><li>应用不需要事务及复杂 JOIN 支持</li><li>新应用, 需求会变, 数据模型无法确定, 想快速迭代开发</li><li>应用需要 2000 - 3000 以上的读写QPS（更高也可以）</li><li>应用需要 TB 甚至 PB 级别数据存储</li><li>应用发展迅速, 需要能快速水平扩展</li><li>应用要求存储的数据不丢失</li><li>应用需要 99.999% 高可用</li><li>应用需要大量的地理位置查询, 文本查询</li></ul><p>如果上述有1个符合, 可以考虑 MongoDB, 2个及以上的符合, 选择MongoDB绝不会后悔。</p><h2 id="1-2-MongoDB-简介"><a href="#1-2-MongoDB-简介" class="headerlink" title="1.2 MongoDB 简介"></a>1.2 MongoDB 简介</h2><p>MongoDB是一个开源, 高性能, 无模式的文档型数据库, 当初的设计就是用于简化开发和方便扩展, 是NoSQL数据库产品中的一种。<strong>是最像关系型数据库（MySQL）的非关系型数据库</strong>。</p><p>它支持的数据结构非常松散, 是一种<strong>类似于JSON的格式叫BSON</strong>, 所以它既可以存储比较复杂的数据类型, 又相当的灵活。</p><p>MongoDB中的记录是一个文档, 它是一个由字段和值对（ﬁeld:value）组成的数据结构。MongoDB文档类似于JSON对象, 即一个文档认为就是一个对象.字段的数据类型是字符型, 它的值除了使用基本的一些类型外, 还可以包括其他文档, 普通数组和文档数组。</p><img src="/2023/05/20/MongoDB/1.png" class="" title="MySQL与MongoDB相比"><img src="/2023/05/20/MongoDB/2.png" class="" title="MySQL与MongoDB相比2"><p>Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><p>MongoDB中的记录是一个文档, 是一个键值对。字段的数据类型是字符型, 值除了使用基本的一些类型以外, 还包括其它文档, 普通数组以及文档数组。</p><p>MongoDB数据类型参考列表如下：</p><img src="/2023/05/20/MongoDB/2.png" class="" title="MySQL与MongoDB相比2"><p>MongoDB数据模型是面向文档的, 所谓文档就是一种类似于JSON的结构, 简单理解MongoDB这个数据库中存在的是各种各样的JSON（BSON）</p><p>在 MongoDB 中, 数据库和集合都不需要手动创建, 当我们创建文档时, 如果文档所在的集合或者数据库不存在, 则会自动创建数据库或者集合</p><h2 id="1-3-MongoDB-特点"><a href="#1-3-MongoDB-特点" class="headerlink" title="1.3 MongoDB 特点"></a>1.3 MongoDB 特点</h2><h3 id="1-3-1-高性能"><a href="#1-3-1-高性能" class="headerlink" title="1.3.1 高性能"></a>1.3.1 高性能</h3><p>MongoDB 提供高性能的数据持久化</p><ul><li>嵌入式数据模型的支持减少了数据库系统上的 I&#x2F;O 活动</li><li>索引支持更快的查询, 并且可以包含来自嵌入式文档和数组的键 (文本索引解决搜索的需求, TTL 索引解决历史数据自动过期的需求, 地理位置索引可以用于构件各种 O2O 应用)</li><li>mmapv1, wiredtiger, mongorocks (rocksdb) in-memory 等多引擎支持满足各种场景需求</li><li>Gridfs 解决文件存储需求</li></ul><h3 id="1-3-2-高可用"><a href="#1-3-2-高可用" class="headerlink" title="1.3.2 高可用"></a>1.3.2 高可用</h3><p>MongoDB 的复制工具称作副本集 (replica set) 可以提供自动故障转移和数据冗余</p><h3 id="1-3-3-高扩展"><a href="#1-3-3-高扩展" class="headerlink" title="1.3.3 高扩展"></a>1.3.3 高扩展</h3><p>水平扩展是其核心功能一部分</p><p>分片将数据分布在一组集群的机器上 (海量数据存储, 服务能力水平扩展)</p><p>MongoDB 支持基于片键创建数据区域, 在一个平衡的集群当中, MongoDB 将一个区域所覆盖的读写只定向到该区域的那些片</p><h3 id="1-3-4-丰富的查询支持"><a href="#1-3-4-丰富的查询支持" class="headerlink" title="1.3.4 丰富的查询支持"></a>1.3.4 丰富的查询支持</h3><p>MongoDB支持丰富的查询语言, 支持读和写操作(CRUD), 比如数据聚合, 文本搜索和地理空间查询等。</p><h3 id="1-3-5-其他特点"><a href="#1-3-5-其他特点" class="headerlink" title="1.3.5 其他特点"></a>1.3.5 其他特点</h3><p>无模式（动态模式）, 灵活的文档模型。</p><h1 id="2-常用基本命令"><a href="#2-常用基本命令" class="headerlink" title="2. 常用基本命令"></a>2. 常用基本命令</h1><h2 id="2-1-数据库操作"><a href="#2-1-数据库操作" class="headerlink" title="2.1 数据库操作"></a>2.1 数据库操作</h2><h3 id="2-1-1-选择和创建数据库"><a href="#2-1-1-选择和创建数据库" class="headerlink" title="2.1.1 选择和创建数据库"></a>2.1.1 选择和创建数据库</h3><p>选择和创建数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果数据库不存在则自动创建</span></span><br><span class="line">use 数据库名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果创建了但是不往里面存东西他是不会保存这个库的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">相当于use 一个不存在的库，会在内存中创建这个库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">但是不往里面放任何集合的话就不会持久化到磁盘</span></span><br></pre></td></tr></table></figure><p>查看有权限查看的所有的数据库命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show dbs </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">show databases</span><br></pre></td></tr></table></figure><p>查看当前正在使用的数据库命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db</span><br><span class="line"><span class="comment">#MongoDB 中默认的数据库为 test，如果你没有选择数据库，集合将存放在 test 数据库中。</span></span><br></pre></td></tr></table></figure><p>另外：</p><p>数据库名可以是满足以下条件的任意UTF-8字符串。</p><ul><li>不能是空字符串（””)。</li><li>不得含有’ ‘（空格)、.、$、&#x2F;、\和\0 (空字符)。</li><li>应全部小写。</li><li>最多64字节。</li></ul><p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p><ul><li>admin：从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特<br>定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li><li>local：这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li><li>config：当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li></ul><h3 id="2-1-2-数据库的删除"><a href="#2-1-2-数据库的删除" class="headerlink" title="2.1.2 数据库的删除"></a>2.1.2 数据库的删除</h3><p>删除已经持久化的数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure><h2 id="2-2集合操作"><a href="#2-2集合操作" class="headerlink" title="2.2集合操作"></a>2.2集合操作</h2><p>集合，类似关系型数据库中的表。</p><p>可以显示的创建，也可以隐式的创建。</p><h3 id="2-2-1-集合的显式创建"><a href="#2-2-1-集合的显式创建" class="headerlink" title="2.2.1 集合的显式创建"></a>2.2.1 集合的显式创建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">name：要创建的集合的名称</span></span><br><span class="line">db.createCollection(name)</span><br></pre></td></tr></table></figure><p>查看当前库中的表：show tables命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show collections </span><br><span class="line">或</span><br><span class="line">show tables</span><br></pre></td></tr></table></figure><p>集合的命名规范：</p><ul><li>集合名不能是空字符串””。</li><li>集合名不能含有\0字符（空字符），这个字符表示集合名的结尾。</li><li>集合名不能以”system.”开头，这是为系统集合保留的前缀。</li><li>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。</li></ul><h3 id="2-2-2-集合的隐式创建"><a href="#2-2-2-集合的隐式创建" class="headerlink" title="2.2.2 集合的隐式创建"></a>2.2.2 集合的隐式创建</h3><p>当向一个集合中插入一个文档的时候，如果集合不存在，则会自动创建集合。</p><h3 id="2-2-3-集合的删除"><a href="#2-2-3-集合的删除" class="headerlink" title="2.2.3 集合的删除"></a>2.2.3 集合的删除</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.collection.drop() </span><br><span class="line">或</span><br><span class="line">db.集合.drop()</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果成功删除选定集合，则 drop() 方法返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span></span><br></pre></td></tr></table></figure><h2 id="2-3-文档基本CRUD"><a href="#2-3-文档基本CRUD" class="headerlink" title="2.3 文档基本CRUD"></a>2.3 文档基本CRUD</h2><p>文档（document）的数据结构和 JSON 基本一样。</p><p>所有存储在集合中的数据都是 BSON 格式。</p><h3 id="2-3-1-文档的插入"><a href="#2-3-1-文档的插入" class="headerlink" title="2.3.1 文档的插入"></a>2.3.1 文档的插入</h3><p>①单个文档插入<br>使用insert()或者save()向集合中插入文档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection.insert( </span><br><span class="line">    &lt;document or array of documents&gt;, </span><br><span class="line">    &#123; </span><br><span class="line">        writeConcern: &lt;document&gt;, </span><br><span class="line">        ordered: &lt;boolean&gt; </span><br><span class="line">    &#125; </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数说明：</p><img src="/2023/05/20/MongoDB/4.png" class="" title="文档插入指令的参数说明"><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.comment.insert(</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;articleid&quot;: &quot;100000&quot;,</span><br><span class="line">        &quot;content&quot;: &quot;今天天气真好,阳光明媚&quot;,</span><br><span class="line">        &quot;userid&quot;: &quot;1001&quot;,</span><br><span class="line">        &quot;nickname&quot;: &quot;Rose&quot;,</span><br><span class="line">        &quot;createdatetime&quot;: new Date(),</span><br><span class="line">        &quot;likenum&quot;: NumberInt(10),</span><br><span class="line">        &quot;state&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>提示：</p><ol><li>comment集合如果不存在，则会隐式创建。</li><li>mongo中的数字，默认情况下是double类型，如果要存整型，必须使用函数NumberInt(整型数字)，否则取出来就有问题了。</li><li>插入当前日期使用 new Date()</li><li>插入的数据没有指定 _id，会自动生成主键值</li><li>如果某字段没值，可以赋值为null，或不写该字段。</li></ol><p>执行后，如下，说明插入一个数据成功了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WriteResult(&#123; &quot;nInserted&quot;: 1 &#125;)</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>文档中的键&#x2F;值对是有序的。</li><li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档）。</li><li>MongoDB区分类型和大小写。</li><li>MongoDB的文档不能有重复的键。</li><li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</li></ol><p>文档键命名规范：</p><ul><li>键不能含有\0 (空字符)。这个字符用来表示键的结尾。</li><li>.和$有特别的意义，只有在特定环境下才能使用。</li><li>以下划线”_”开头的键是保留的(不是严格要求的)。</li></ul><p>②批量插入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.collection.insertMany( [ </span><br><span class="line">        &lt;document 1&gt;, </span><br><span class="line">        &lt;document 2&gt;,</span><br><span class="line">        ... </span><br><span class="line">    ], </span><br><span class="line">    &#123; </span><br><span class="line">        writeConcern: &lt;document&gt;, </span><br><span class="line">        ordered: &lt;boolean&gt; </span><br><span class="line">    &#125; </span><br><span class="line">)</span><br></pre></td></tr></table></figure><img src="/2023/05/20/MongoDB/5.png" class="" title="批量插入指令的参数说明"><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">db.comment.insertMany([ </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">            &quot;articleid&quot;: &quot;100001&quot;,</span><br><span class="line">            &quot;content&quot;: &quot;我们不应该把清晨浪费在手机上，健康很重要，一杯温水幸福你我他。&quot;,</span><br><span class="line">            &quot;userid&quot;: &quot;1002&quot;,</span><br><span class="line">            &quot;nickname&quot;: &quot;相忘于江湖&quot;,</span><br><span class="line">            &quot;createdatetime&quot;: new Date(&quot;2019-08-05T22:08:15.522Z&quot;),</span><br><span class="line">            &quot;likenum&quot;:NumberInt(1000),</span><br><span class="line">            &quot;state&quot;:&quot;1&quot;</span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_id&quot;:&quot;2&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我夏天空腹喝凉开水，冬天喝温开水&quot;,&quot;userid&quot;:&quot;1005&quot;,&quot;nickname&quot;:&quot;伊人憔 悴&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-05T23:58:51.485Z&quot;),&quot;likenum&quot;:NumberInt(888),&quot;state&quot;:&quot;1&quot;</span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_id&quot;:&quot;3&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我一直喝凉开水，冬天夏天都喝。&quot;,&quot;userid&quot;:&quot;1004&quot;,&quot;nickname&quot;:&quot;杰克船 长&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-06T01:05:06.321Z&quot;),&quot;likenum&quot;:NumberInt(666),&quot;state&quot;:&quot;1&quot;</span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_id&quot;:&quot;4&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;专家说不能空腹吃饭，影响健康。&quot;,&quot;userid&quot;:&quot;1003&quot;,&quot;nickname&quot;:&quot;凯 撒&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-06T08:18:35.288Z&quot;),&quot;likenum&quot;:NumberInt(2000),&quot;state&quot;:&quot;1&quot;</span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_id&quot;:&quot;5&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;研究表明，刚烧开的水千万不能喝，因为烫 嘴。&quot;,&quot;userid&quot;:&quot;1003&quot;,&quot;nickname&quot;:&quot;凯撒&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08- 06T11:01:02.521Z&quot;),&quot;likenum&quot;:NumberInt(3000),&quot;state&quot;:&quot;1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>提示：</p><p>插入时指定了_id ，则主键就是该值。</p><p>如果某条数据插入失败，将会终止插入，但已经插入成功的数据不会回滚掉。</p><p>因为批量插入由于数据较多容易出现失败，因此，可以使用try catch进行异常捕捉处理，测试的时候可以不处理。<br>如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">try &#123; </span><br><span class="line">    db.comment.insertMany([ </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_id&quot;:&quot;1&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我们不应该把清晨浪费在手机上，健康很重要，一杯温水幸福你我 他。&quot;,&quot;userid&quot;:&quot;1002&quot;,&quot;nickname&quot;:&quot;相忘于江湖&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08- 05T22:08:15.522Z&quot;),</span><br><span class="line">            &quot;likenum&quot;:NumberInt(1000),</span><br><span class="line">            &quot;state&quot;:&quot;1&quot;</span><br><span class="line">        &#125;, </span><br><span class="line">            &#123;&quot;_id&quot;:&quot;2&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我夏天空腹喝凉开水，冬天喝温开水&quot;,&quot;userid&quot;:&quot;1005&quot;,&quot;nickname&quot;:&quot;伊人憔 悴&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-05T23:58:51.485Z&quot;),</span><br><span class="line">            &quot;likenum&quot;:NumberInt(888),</span><br><span class="line">            &quot;state&quot;:&quot;1&quot;&#125;, </span><br><span class="line">            &#123;&quot;_id&quot;:&quot;3&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;我一直喝凉开水，冬天夏天都喝。&quot;,&quot;userid&quot;:&quot;1004&quot;,&quot;nickname&quot;:&quot;杰克船 长&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-06T01:05:06.321Z&quot;),</span><br><span class="line">            &quot;likenum&quot;:NumberInt(666),</span><br><span class="line">            &quot;state&quot;:&quot;1&quot;&#125;, </span><br><span class="line">            &#123;&quot;_id&quot;:&quot;4&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;专家说不能空腹吃饭，影响健康。&quot;,&quot;userid&quot;:&quot;1003&quot;,&quot;nickname&quot;:&quot;凯 撒&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08-06T08:18:35.288Z&quot;),</span><br><span class="line">            &quot;likenum&quot;:NumberInt(2000),</span><br><span class="line">            &quot;state&quot;:&quot;1&quot;&#125;, </span><br><span class="line">            &#123;&quot;_id&quot;:&quot;5&quot;,&quot;articleid&quot;:&quot;100001&quot;,&quot;content&quot;:&quot;研究表明，刚烧开的水千万不能喝，因为烫 嘴。&quot;,&quot;userid&quot;:&quot;1003&quot;,&quot;nickname&quot;:&quot;凯撒&quot;,&quot;createdatetime&quot;:new Date(&quot;2019-08- 06T11:01:02.521Z&quot;),</span><br><span class="line">            &quot;likenum&quot;:NumberInt(3000),</span><br><span class="line">            &quot;state&quot;:&quot;1&quot;</span><br><span class="line">        &#125; </span><br><span class="line">    ]); </span><br><span class="line">&#125; catch (e) &#123; </span><br><span class="line">    print (e); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-文档的基本查询"><a href="#2-3-2-文档的基本查询" class="headerlink" title="2.3.2 文档的基本查询"></a>2.3.2 文档的基本查询</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(&lt;query&gt;, [projection])</span><br></pre></td></tr></table></figure><img src="/2023/05/20/MongoDB/6.png" class="" title="文档的基本查询指令的参数说明"><p>例子：</p><p>①查询所有</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果我们要查询spit集合的所有文档，我们输入以下命令</span></span><br><span class="line">db.comment.find() </span><br><span class="line">或</span><br><span class="line">db.comment.find(&#123;&#125;)</span><br></pre></td></tr></table></figure><p>这里你会发现每条文档会有一个叫_id的字段，这个相当于我们原来关系数据库中表的主键，当你在插入文档记录时没有指定该字段，MongoDB会自动创建，其类型是ObjectID类型。</p><p>如果我们在插入文档记录时指定该字段也可以，其类型可以是ObjectID类型，也可以是MongoDB支持的任意类型。</p><p>如果我想按一定条件来查询，比如我想查询userid为1003的记录，怎么办？很简单！只要在find()中添加参数即可，参数也是json格式，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;userid:&#x27;1003&#x27;&#125;)</span><br></pre></td></tr></table></figure><p>如果你只需要返回符合条件的第一条数据，我们可以使用findOne命令来实现，语法和find一样。<br>如：查询用户编号是1003的记录，但只最多返回符合条件的第一条记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.findOne(&#123;userid:&#x27;1003&#x27;&#125;)</span><br></pre></td></tr></table></figure><p>②投影查询（Projection Query）：</p><p>如果要查询结果返回部分字段，则需要使用投影查询（不显示所有字段，只显示指定的字段）。</p><p>如：查询结果只显示 _id、userid、nickname：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:1,nickname:1&#125;) </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">出现如下结果</span></span><br><span class="line">&#123; &quot;_id&quot; : &quot;4&quot;, &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125; </span><br><span class="line">&#123; &quot;_id&quot; : &quot;5&quot;, &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125;</span><br></pre></td></tr></table></figure><p>可以发现默认 _id 会自动显示。</p><p>如果不想让他出现可以这样操作：<br>如：查询结果只显示 、userid、nickname ，不显示 _id ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:1,nickname:1,_id:0&#125;) </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">出现如下结果</span></span><br><span class="line">&#123; &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125; </span><br><span class="line">&#123; &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-文档的更新"><a href="#2-3-3-文档的更新" class="headerlink" title="2.3.3 文档的更新"></a>2.3.3 文档的更新</h3><p>更新文档的语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(query, update, options) </span><br><span class="line">//或 </span><br><span class="line">db.collection.update( </span><br><span class="line">    &lt;query&gt;, </span><br><span class="line">    &lt;update&gt;, </span><br><span class="line">    &#123; </span><br><span class="line">        upsert: &lt;boolean&gt;, </span><br><span class="line">        multi: &lt;boolean&gt;, </span><br><span class="line">        writeConcern: &lt;document&gt;, </span><br><span class="line">        collation: &lt;document&gt;, </span><br><span class="line">        arrayFilters: [ </span><br><span class="line">            &lt;filterdocument1&gt;, </span><br><span class="line">            ... </span><br><span class="line">        ], </span><br><span class="line">        hint: &lt;document|string&gt; // Available starting in MongoDB 4.2 </span><br><span class="line">    &#125; </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数：</p><img src="/2023/05/20/MongoDB/7.png" class="" title="文档的更新指令的参数说明"><h3 id="2-3-4-文档的删除"><a href="#2-3-4-文档的删除" class="headerlink" title="2.3.4 文档的删除"></a>2.3.4 文档的删除</h3><p>①db.<collection_name>.deleteMany()<br>删除所有匹配的文档.</p><p>②db.<collection_name>.deleteOne()<br>删除单个匹配的文档</p><p>例1：删除 userId&#x3D;456 的所有文档</p><img src="/2023/05/20/MongoDB/8.png" class="" title="文档的删除演示"><h1 id="3-索引"><a href="#3-索引" class="headerlink" title="3 索引"></a>3 索引</h1><p>MongoDB中的索引使得其查询效率变得更高了，MongoDB的索引原理和MySQL的一样。</p><h2 id="3-1-索引的分类"><a href="#3-1-索引的分类" class="headerlink" title="3.1 索引的分类"></a>3.1 索引的分类</h2><p>1、单字段索引<br>MongoDB 支持在文档的单个字段上创建用户定义的升序&#x2F;降序索引, 称为单字段索引</p><p>2、复合索引<br>MongoDB 支持多个字段的用户定义索引, 即复合索引 </p><p>3、地理空间索引<br>为了支持对地理空间坐标数据的有效查询, MongoDB 提供了两种特殊的索引: 返回结果时使用平面几何的二维索引和返回结果时使用球面几何的二维球面索引</p><p>4、哈希索引<br>为了支持基于散列的分片, MongoDB 提供了散列索引类型, 它对字段值的散列进行索引.这些索引在其范围内的值分布更加随机, 但只支持相等匹配, 不支持基于范围的查询.</p><p>5、文本索引<br>MongoDB 提供了一种文本索引类型, 支持在集合中搜索字符串内容，这些文本索引不存储特定于语言的停止词（例如 “the”, “a”, “or”）, 而将集合中的词作为词干, 只存储根词。</p><h2 id="3-2-索引的相关命令"><a href="#3-2-索引的相关命令" class="headerlink" title="3.2 索引的相关命令"></a>3.2 索引的相关命令</h2><p>①db.<collection_name>.getIndexes() 查看索引</p><img src="/2023/05/20/MongoDB/9.png" class="" title="查看索引"><p>②db.<collection_name>.createIndex() 创建索引</p><img src="/2023/05/20/MongoDB/10.png" class="" title="创建索引"><p>③db.Test.dropIndex() 删除索引</p><p>db.Test.dropIndexes() 删除所有索引【默认的_id索引不会被删除】</p><img src="/2023/05/20/MongoDB/11.png" class="" title="删除索引"><p>④explain() 查看执行计划</p><img src="/2023/05/20/MongoDB/12.png" class="" title="查看执行计划"><h1 id="4-副本集"><a href="#4-副本集" class="headerlink" title="4 副本集"></a>4 副本集</h1><p>MongoDB 通过使用副本集来实现复制，副本集只能有一个主节点。</p><ul><li>副本集是一组两个或更多节点（通常最少需要 3 个节点）；</li><li>在副本集中，一个节点是主要节点，其余节点是从节点；</li><li>所有数据从主节点复制到从节点；</li><li>在自动故障转移或维护时，将为主节点建立选举，并选举一个新的主节点；</li><li>恢复失败的节点后，它再次加入副本集并用作辅助节点。</li><li>副本集中，主节点 和 从节点 中数据是一样的，从节点和主节点保持一致</li></ul><img src="/2023/05/20/MongoDB/13.png" class="" title="副本集"><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">副本集是指同一份数据被保存到N个机器上，每个机器上都是想同的数据。</span><br><span class="line"></span><br><span class="line">分片是指一份数据被分离开保存到N个机器上，N个机器上的数据组合起来是一份数据。</span><br></pre></td></tr></table></figure><h1 id="5-分片"><a href="#5-分片" class="headerlink" title="5 分片"></a>5 分片</h1><h2 id="5-1-分片是什么？"><a href="#5-1-分片是什么？" class="headerlink" title="5.1 分片是什么？"></a>5.1 分片是什么？</h2><p>分片是<strong>跨多台机器存储数据</strong>的过程，它是 MongoDB 满足数据增长需求的方法。随着数据的不断增加，单台机器可能不足以存储全部数据，也无法提供足够的读写吞吐量。通过分片，可以添加更多计算机来满足数据增长和读&#x2F;写操作的需求。<strong>分片中，不同机器内存储的数据是不一样的</strong></p><h2 id="5-2-有副本集不就够了，为什么要分片？"><a href="#5-2-有副本集不就够了，为什么要分片？" class="headerlink" title="5.2 有副本集不就够了，为什么要分片？"></a>5.2 有副本集不就够了，为什么要分片？</h2><ul><li>在复制中，所有写操作都将转到主节点；</li><li>对延迟敏感的查询仍会转到主查询；</li><li>单个副本集限制为 12 个节点；</li><li>当活动数据集很大时，会出现内存不足；</li><li>本地磁盘不够大；</li><li>垂直扩展价格昂贵。</li></ul><h2 id="5-3-分片结构"><a href="#5-3-分片结构" class="headerlink" title="5.3 分片结构"></a>5.3 分片结构</h2><img src="/2023/05/20/MongoDB/14.png" class="" title="分片结构"><ul><li>Shards（碎片）：用于<strong>存储实际的数据块</strong>，在生产环境中，每个分片都是一个单独的副本集，它们提供了高可用性和数据一致性；</li><li>Config Servers（配置服务器）：用于存储集群的元数据，此数据包含集群数据集到碎片的映射。查询路由器使用此元数据将操作定向到特定的碎片。在生产环境中，分片群集恰好具有 3 个配置服务器；</li><li>Query Routers（查询路由器）：查询路由器基本上都是 mongo 实例，可与客户端应用程序接口并将操作定向到适当的分片。<strong>查询路由器处理操作并将其定位到分片，然后将结果返回给客户端</strong>。分片群集可以包含多个查询路由器来划分客户端请求负载。客户端将请求发送到一个查询路由器。通常，<strong>分片群集具有许多查询路由器</strong>。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> 非关系型数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
